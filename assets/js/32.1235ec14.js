(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{219:function(e,t,r){"use strict";r.r(t);var a=r(2),n=Object(a.a)({},function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h1",{attrs:{id:"introduction"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#introduction","aria-hidden":"true"}},[e._v("#")]),e._v(" Introduction")]),e._v(" "),r("p",[e._v("SPARQL.ex is an implementation of the "),r("a",{attrs:{href:"http://www.w3.org/TR/sparql11-overview/",target:"_blank",rel:"noopener noreferrer"}},[e._v("SPARQL"),r("OutboundLink")],1),e._v(" standards for Elixir. It allows to execute SPARQL queries against "),r("a",{attrs:{href:"/rdf-ex"}},[e._v("RDF.ex")]),e._v(" data structures.")]),e._v(" "),r("p",[e._v("The implementation of the "),r("a",{attrs:{href:"https://www.w3.org/TR/sparql11-protocol/",target:"_blank",rel:"noopener noreferrer"}},[e._v("SPARQL protocol"),r("OutboundLink")],1),e._v(" is separated into the "),r("code",[e._v("SPARQL.Client")]),e._v(" project. It executes SPARQL queries against any SPARQL 1.0/1.1-compatible endpoint over HTTP and supports result sets in both XML, JSON, CSV and TSV formats, with JSON being the preferred default for content-negotiation purposes.\nGraph results from "),r("code",[e._v("CONSTRUCT")]),e._v(" queries can be read in any serialization format supported by "),r("a",{attrs:{href:"/rdf-ex/serializations"}},[e._v("RDF.ex")]),e._v(" and will be directly deserialized to the respective "),r("a",{attrs:{href:"/rdf-ex/data-structures"}},[e._v("RDF.ex data structure")]),e._v(".")])])},[],!1,null,null,null);t.default=n.exports}}]);