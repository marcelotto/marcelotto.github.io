<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Literals | RDF on Elixir</title>
    <meta name="description" content="Implementation of the Linked Data and Semantic Standards for Elixir">
    <link rel="manifest" href="/icons/manifest.json">
  <link rel="icon" type="image/x-icon" sizes="16x16 32x32" href="/icons/favicon.ico">
  <link rel="icon" sizes="192x192" href="/icons/favicon-192.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/favicon-180-precomposed.png">
  <meta name="msapplication-TileImage" content="/icons/favicon-144.png">
  <meta name="msapplication-TileColor" content="#FFFFFF">
  <meta name="theme-color" content="#3eaf7c">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
    
    <link rel="preload" href="/assets/css/0.styles.26047e9a.css" as="style"><link rel="preload" href="/assets/js/app.9947d21f.js" as="script"><link rel="preload" href="/assets/js/2.9c83fda1.js" as="script"><link rel="preload" href="/assets/js/22.3ae550ed.js" as="script"><link rel="preload" href="/assets/js/3.6456fe17.js" as="script"><link rel="prefetch" href="/assets/js/10.ee4ed3c6.js"><link rel="prefetch" href="/assets/js/11.467615b9.js"><link rel="prefetch" href="/assets/js/12.6022d75e.js"><link rel="prefetch" href="/assets/js/13.b74f4730.js"><link rel="prefetch" href="/assets/js/14.16bc6703.js"><link rel="prefetch" href="/assets/js/15.b2a2c70a.js"><link rel="prefetch" href="/assets/js/16.16aff3dd.js"><link rel="prefetch" href="/assets/js/17.e92fb19a.js"><link rel="prefetch" href="/assets/js/18.029f34a1.js"><link rel="prefetch" href="/assets/js/19.05cb4c74.js"><link rel="prefetch" href="/assets/js/20.269187c7.js"><link rel="prefetch" href="/assets/js/21.bb8ba48a.js"><link rel="prefetch" href="/assets/js/23.fd1aa42f.js"><link rel="prefetch" href="/assets/js/24.da208f76.js"><link rel="prefetch" href="/assets/js/25.0da14ab4.js"><link rel="prefetch" href="/assets/js/26.db8227de.js"><link rel="prefetch" href="/assets/js/27.4c9e9654.js"><link rel="prefetch" href="/assets/js/28.54a222e6.js"><link rel="prefetch" href="/assets/js/29.bf2a75a3.js"><link rel="prefetch" href="/assets/js/30.1a834a5c.js"><link rel="prefetch" href="/assets/js/31.e898f5f2.js"><link rel="prefetch" href="/assets/js/32.1235ec14.js"><link rel="prefetch" href="/assets/js/33.abbed48e.js"><link rel="prefetch" href="/assets/js/34.4b01380f.js"><link rel="prefetch" href="/assets/js/35.3d8d8b6b.js"><link rel="prefetch" href="/assets/js/36.6466eb8a.js"><link rel="prefetch" href="/assets/js/37.d63216a3.js"><link rel="prefetch" href="/assets/js/38.5f244a36.js"><link rel="prefetch" href="/assets/js/39.292a3e39.js"><link rel="prefetch" href="/assets/js/4.54ba1511.js"><link rel="prefetch" href="/assets/js/40.feb4961e.js"><link rel="prefetch" href="/assets/js/5.d4e734fc.js"><link rel="prefetch" href="/assets/js/6.dd985d23.js"><link rel="prefetch" href="/assets/js/7.98d61040.js"><link rel="prefetch" href="/assets/js/8.86f42866.js"><link rel="prefetch" href="/assets/js/9.5dff1e2d.js">
    <link rel="stylesheet" href="/assets/css/0.styles.26047e9a.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">RDF on Elixir</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/rdf-ex/" class="nav-link router-link-active">RDF.ex</a></div><div class="nav-item"><a href="/sparql-ex/" class="nav-link">SPARQL.ex</a></div><div class="nav-item"><a href="/shex-ex/" class="nav-link">ShEx.ex</a></div><div class="nav-item"><a href="/grax/" class="nav-link">Grax</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">API Documentation</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://hexdocs.pm/rdf/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  RDF.ex
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="https://hexdocs.pm/sparql/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  SPARQL.ex
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="https://hexdocs.pm/sparql_client/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  SPARQL.Client
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="https://hexdocs.pm/shex/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  ShEx.ex
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="https://hexdocs.pm/json_ld/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  JSON-LD.ex
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="https://hexdocs.pm/rdf_xml/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  RDF-XML.ex
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div></div><div class="nav-item"><a href="/links.html" class="nav-link">Links</a></div> <a href="https://github.com/rdf-elixir/website" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/rdf-ex/" class="nav-link router-link-active">RDF.ex</a></div><div class="nav-item"><a href="/sparql-ex/" class="nav-link">SPARQL.ex</a></div><div class="nav-item"><a href="/shex-ex/" class="nav-link">ShEx.ex</a></div><div class="nav-item"><a href="/grax/" class="nav-link">Grax</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">API Documentation</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://hexdocs.pm/rdf/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  RDF.ex
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="https://hexdocs.pm/sparql/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  SPARQL.ex
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="https://hexdocs.pm/sparql_client/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  SPARQL.Client
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="https://hexdocs.pm/shex/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  ShEx.ex
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="https://hexdocs.pm/json_ld/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  JSON-LD.ex
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="https://hexdocs.pm/rdf_xml/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  RDF-XML.ex
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div></div><div class="nav-item"><a href="/links.html" class="nav-link">Links</a></div> <a href="https://github.com/rdf-elixir/website" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>RDF.ex</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/rdf-ex/" class="sidebar-link">Introduction</a></li><li><a href="/rdf-ex/installation.html" class="sidebar-link">Installation</a></li><li><a href="/rdf-ex/iris.html" class="sidebar-link">IRIs</a></li><li><a href="/rdf-ex/vocabularies.html" class="sidebar-link">Vocabularies</a></li><li><a href="/rdf-ex/blank-nodes.html" class="sidebar-link">Blank nodes</a></li><li><a href="/rdf-ex/literals.html" class="active sidebar-link">Literals</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/rdf-ex/literals.html#untyped-literals" class="sidebar-link">Untyped literals</a></li><li class="sidebar-sub-header"><a href="/rdf-ex/literals.html#language-tagged-literals" class="sidebar-link">Language-tagged literals</a></li><li class="sidebar-sub-header"><a href="/rdf-ex/literals.html#typed-literals" class="sidebar-link">Typed literals</a></li><li class="sidebar-sub-header"><a href="/rdf-ex/literals.html#validation" class="sidebar-link">Validation</a></li><li class="sidebar-sub-header"><a href="/rdf-ex/literals.html#lexical-and-canonical-form" class="sidebar-link">Lexical and canonical form</a></li><li class="sidebar-sub-header"><a href="/rdf-ex/literals.html#equivalence" class="sidebar-link">Equivalence</a></li><li class="sidebar-sub-header"><a href="/rdf-ex/literals.html#defining-custom-datatypes" class="sidebar-link">Defining custom datatypes</a></li><li class="sidebar-sub-header"><a href="/rdf-ex/literals.html#type-checking-and-reflection" class="sidebar-link">Type checking and reflection</a></li></ul></li><li><a href="/rdf-ex/statements.html" class="sidebar-link">Statements</a></li><li><a href="/rdf-ex/data-structures.html" class="sidebar-link">RDF data structures</a></li><li><a href="/rdf-ex/lists.html" class="sidebar-link">Lists</a></li><li><a href="/rdf-ex/mapping-between-rdf-and-elixir.html" class="sidebar-link">Mapping of RDF terms and structures</a></li><li><a href="/rdf-ex/serializations.html" class="sidebar-link">Serializations</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="literals"><a href="#literals" aria-hidden="true" class="header-anchor">#</a> Literals</h1> <p>Literals are used for values such as strings, numbers, and dates. They can be untyped, languaged-tagged or typed (but following the RDF 1.1 spec untyped literals are in fact just <code>xsd:string</code> typed literals)</p> <h2 id="untyped-literals"><a href="#untyped-literals" aria-hidden="true" class="header-anchor">#</a> Untyped literals</h2> <p>In general literals are created with the <code>RDF.Literal.new</code> constructor function or its alias function <code>RDF.literal</code>:</p> <div class="language-elixir extra-class"><pre class="language-elixir"><code>RDF<span class="token punctuation">.</span>Literal<span class="token punctuation">.</span>new<span class="token punctuation">(</span><span class="token string">&quot;foo&quot;</span><span class="token punctuation">)</span>
RDF<span class="token punctuation">.</span>literal<span class="token punctuation">(</span><span class="token string">&quot;foo&quot;</span><span class="token punctuation">)</span>
</code></pre></div><p>The actual value can be accessed via the <code>RDF.Literal.value/1</code> function:</p> <div class="language-elixir extra-class"><pre class="language-elixir"><code>iex<span class="token operator">&gt;</span> RDF<span class="token punctuation">.</span>literal<span class="token punctuation">(</span><span class="token string">&quot;foo&quot;</span><span class="token punctuation">)</span> <span class="token operator">|&gt;</span> RDF<span class="token punctuation">.</span>Literal<span class="token punctuation">.</span>value<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token string">&quot;foo&quot;</span>
</code></pre></div><p>An untyped literal can also be created with the <code>~L</code> sigil:</p> <div class="language-elixir extra-class"><pre class="language-elixir"><code><span class="token keyword">import</span> RDF<span class="token punctuation">.</span>Sigils

~L<span class="token string">&quot;foo&quot;</span>
</code></pre></div><h2 id="language-tagged-literals"><a href="#language-tagged-literals" aria-hidden="true" class="header-anchor">#</a> Language-tagged literals</h2> <p>A language-tagged literal can be created by providing the <code>language</code> option with a <a href="https://tools.ietf.org/html/bcp47" target="_blank" rel="noopener noreferrer">BCP47<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>-conform language or by adding the language as a modifier to the <code>~L</code> sigil:</p> <div class="language-elixir extra-class"><pre class="language-elixir"><code><span class="token keyword">import</span> RDF<span class="token punctuation">.</span>Sigils

RDF<span class="token punctuation">.</span>literal<span class="token punctuation">(</span><span class="token string">&quot;foo&quot;</span><span class="token punctuation">,</span> <span class="token attr-name">language:</span> <span class="token string">&quot;en&quot;</span><span class="token punctuation">)</span>

~L<span class="token string">&quot;foo&quot;</span>en
</code></pre></div><p>Note: Only languages without subtags are supported as modifiers of the <code>~L</code> sigil, i.e. if you want to use <code>en-US</code> as a language tag, you would have to use the constructor functions.</p> <h2 id="typed-literals"><a href="#typed-literals" aria-hidden="true" class="header-anchor">#</a> Typed literals</h2> <p>A typed literal can be created by providing the <code>datatype</code> option with an IRI of a datatype. Most of the time this will be an <a href="https://www.w3.org/TR/xmlschema11-2/" target="_blank" rel="noopener noreferrer">XML schema datatype<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>:</p> <div class="language-elixir extra-class"><pre class="language-elixir"><code><span class="token keyword">alias</span> RDF<span class="token punctuation">.</span>NS

RDF<span class="token punctuation">.</span>literal<span class="token punctuation">(</span><span class="token string">&quot;42&quot;</span><span class="token punctuation">,</span> <span class="token attr-name">datatype:</span> NS<span class="token punctuation">.</span>XSD<span class="token punctuation">.</span>integer<span class="token punctuation">)</span>
</code></pre></div><p>It is also possible to create a typed literal by using a native Elixir non-string value, for which the following datatype mapping will be applied:</p> <table><thead><tr><th style="text-align:left;">Elixir datatype</th> <th style="text-align:left;">XSD datatype</th></tr></thead> <tbody><tr><td style="text-align:left;"><code>string</code></td> <td style="text-align:left;"><code>xsd:string</code></td></tr> <tr><td style="text-align:left;"><code>boolean</code></td> <td style="text-align:left;"><code>xsd:boolean</code></td></tr> <tr><td style="text-align:left;"><code>integer</code></td> <td style="text-align:left;"><code>xsd:integer</code></td></tr> <tr><td style="text-align:left;"><code>float</code></td> <td style="text-align:left;"><code>xsd:double</code></td></tr> <tr><td style="text-align:left;"><a href="https://github.com/ericmj/decimal" target="_blank" rel="noopener noreferrer"><code>Decimal</code><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></td> <td style="text-align:left;"><code>xsd:decimal</code></td></tr> <tr><td style="text-align:left;"><code>Time</code></td> <td style="text-align:left;"><code>xsd:time</code></td></tr> <tr><td style="text-align:left;"><code>Date</code></td> <td style="text-align:left;"><code>xsd:date</code></td></tr> <tr><td style="text-align:left;"><code>DateTime</code></td> <td style="text-align:left;"><code>xsd:dateTime</code></td></tr> <tr><td style="text-align:left;"><code>NaiveDateTime</code></td> <td style="text-align:left;"><code>xsd:dateTime</code></td></tr> <tr><td style="text-align:left;"><code>URI</code></td> <td style="text-align:left;"><code>xsd:AnyURI</code></td></tr></tbody></table> <p>So the former example literal can be created equivalently like this:</p> <div class="language-elixir extra-class"><pre class="language-elixir"><code>RDF<span class="token punctuation">.</span>literal<span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span>
</code></pre></div><p>The <code>value/1</code> function returns the literal value as the native Elixir value according to the above mapping. When a known XSD datatype is specified, the given value will be converted automatically if needed and possible.</p> <div class="language-elixir extra-class"><pre class="language-elixir"><code>iex<span class="token operator">&gt;</span> RDF<span class="token punctuation">.</span>literal<span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">,</span> <span class="token attr-name">datatype:</span> NS<span class="token punctuation">.</span>XSD<span class="token punctuation">.</span>double<span class="token punctuation">)</span> <span class="token operator">|&gt;</span> RDF<span class="token punctuation">.</span>Literal<span class="token punctuation">.</span>value<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token number">42.0</span>

iex<span class="token operator">&gt;</span> RDF<span class="token punctuation">.</span>literal<span class="token punctuation">(</span><span class="token string">&quot;0042&quot;</span><span class="token punctuation">,</span> <span class="token attr-name">datatype:</span> NS<span class="token punctuation">.</span>XSD<span class="token punctuation">.</span>byte<span class="token punctuation">)</span> <span class="token operator">|&gt;</span> RDF<span class="token punctuation">.</span>Literal<span class="token punctuation">.</span>value<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token number">42</span>
</code></pre></div><div class="warning custom-block"><p>For some datatypes where the value space of the XSD datatype is larger than what the corresponding Elixir datatype supports, you might also get a tuple with annotations back. For example, <code>xsd:date</code>s and <code>xsd:time</code>s support timezones while Elixir's <code>Date</code> and <code>Time</code> structs don't support that. In case of an <code>xsd:date</code> with a timezone you'll get a tuple like this <code>{~D[2014-09-01], &quot;-08:00&quot;}</code>. For <code>xsd:time</code>s with timezones you'll instead just get a tuple like <code>{~T[23:00:00], true}</code> with a boolean signifying that it has a timezone, since the timezone offset was already normalized in the value (the original timezone offset is kept in the lexical form).</p></div> <p>For all of the supported RDF and XSD datatypes there are <code>RDF.Literal.Datatype</code> modules available that implement the semantics of the respective datatype.
They also provide a <code>new</code> constructor function that allows the creation of <code>RDF.Literal</code>s with the respective datatype. These constructor can also be called via the alias functions on the top-level <code>RDF</code> respective <code>RDF.XSD</code> namespace.</p> <div class="language-elixir extra-class"><pre class="language-elixir"><code><span class="token comment"># we'll consider the following alias to be defined throughout this guide implicitly</span>
<span class="token keyword">alias</span> RDF<span class="token punctuation">.</span>XSD

XSD<span class="token punctuation">.</span>String<span class="token punctuation">.</span>new<span class="token punctuation">(</span><span class="token string">&quot;foo&quot;</span><span class="token punctuation">)</span>
XSD<span class="token punctuation">.</span>string<span class="token punctuation">(</span><span class="token string">&quot;foo&quot;</span><span class="token punctuation">)</span>
XSD<span class="token punctuation">.</span>integer<span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span>
XSD<span class="token punctuation">.</span>byte<span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span>
RDF<span class="token punctuation">.</span>LangString<span class="token punctuation">.</span>new<span class="token punctuation">(</span><span class="token string">&quot;foo&quot;</span><span class="token punctuation">,</span> <span class="token attr-name">language:</span> <span class="token string">&quot;en&quot;</span><span class="token punctuation">)</span>
RDF<span class="token punctuation">.</span>langString<span class="token punctuation">(</span><span class="token string">&quot;foo&quot;</span><span class="token punctuation">,</span> <span class="token attr-name">language:</span> <span class="token string">&quot;en&quot;</span><span class="token punctuation">)</span>
</code></pre></div><p>Besides the <code>RDF.LangString</code> datatype the following XSD datatypes are provided as <code>RDF.Literal.Datatype</code>s:</p> <table><thead><tr><th style="text-align:left;">XSD datatype</th> <th style="text-align:left;"><code>RDF.Literal.Datatype</code></th></tr></thead> <tbody><tr><td style="text-align:left;"><code>xsd:boolean</code></td> <td style="text-align:left;"><code>RDF.XSD.Boolean</code></td></tr> <tr><td style="text-align:left;"><code>xsd:float</code></td> <td style="text-align:left;"><code>RDF.XSD.Float</code></td></tr> <tr><td style="text-align:left;"><code>xsd:double</code></td> <td style="text-align:left;"><code>RDF.XSD.Double</code></td></tr> <tr><td style="text-align:left;"><code>xsd:decimal</code></td> <td style="text-align:left;"><code>RDF.XSD.Decimal</code></td></tr> <tr><td style="text-align:left;"><code>xsd:integer</code></td> <td style="text-align:left;"><code>RDF.XSD.Integer</code></td></tr> <tr><td style="text-align:left;"><code>xsd:long</code></td> <td style="text-align:left;"><code>RDF.XSD.Long</code></td></tr> <tr><td style="text-align:left;"><code>xsd:int</code></td> <td style="text-align:left;"><code>RDF.XSD.Int</code></td></tr> <tr><td style="text-align:left;"><code>xsd:short</code></td> <td style="text-align:left;"><code>RDF.XSD.Short</code></td></tr> <tr><td style="text-align:left;"><code>xsd:byte</code></td> <td style="text-align:left;"><code>RDF.XSD.Byte</code></td></tr> <tr><td style="text-align:left;"><code>xsd:nonPositiveInteger</code></td> <td style="text-align:left;"><code>RDF.XSD.NonPositiveInteger</code></td></tr> <tr><td style="text-align:left;"><code>xsd:negativeInteger</code></td> <td style="text-align:left;"><code>RDF.XSD.NegativeInteger</code></td></tr> <tr><td style="text-align:left;"><code>xsd:nonNegativeInteger</code></td> <td style="text-align:left;"><code>RDF.XSD.NonNegativeInteger</code></td></tr> <tr><td style="text-align:left;"><code>xsd:positiveInteger</code></td> <td style="text-align:left;"><code>RDF.XSD.PositiveInteger</code></td></tr> <tr><td style="text-align:left;"><code>xsd:unsignedLong</code></td> <td style="text-align:left;"><code>RDF.XSD.UnsignedLong</code></td></tr> <tr><td style="text-align:left;"><code>xsd:unsignedInt</code></td> <td style="text-align:left;"><code>RDF.XSD.UnsignedInt</code></td></tr> <tr><td style="text-align:left;"><code>xsd:unsignedShort</code></td> <td style="text-align:left;"><code>RDF.XSD.UnsignedShort</code></td></tr> <tr><td style="text-align:left;"><code>xsd:unsignedByte</code></td> <td style="text-align:left;"><code>RDF.XSD.UnsignedByte</code></td></tr> <tr><td style="text-align:left;"><code>xsd:string</code></td> <td style="text-align:left;"><code>RDF.XSD.String</code></td></tr> <tr><td style="text-align:left;"><code>xsd:normalizedString</code></td> <td style="text-align:left;">❌</td></tr> <tr><td style="text-align:left;"><code>xsd:token</code></td> <td style="text-align:left;">❌</td></tr> <tr><td style="text-align:left;"><code>xsd:language</code></td> <td style="text-align:left;">❌</td></tr> <tr><td style="text-align:left;"><code>xsd:Name</code></td> <td style="text-align:left;">❌</td></tr> <tr><td style="text-align:left;"><code>xsd:NCName</code></td> <td style="text-align:left;">❌</td></tr> <tr><td style="text-align:left;"><code>xsd:ID</code></td> <td style="text-align:left;">❌</td></tr> <tr><td style="text-align:left;"><code>xsd:IDREF</code></td> <td style="text-align:left;">❌</td></tr> <tr><td style="text-align:left;"><code>xsd:ENTITY</code></td> <td style="text-align:left;">❌</td></tr> <tr><td style="text-align:left;"><code>xsd:NMTOKEN</code></td> <td style="text-align:left;">❌</td></tr> <tr><td style="text-align:left;"><code>xsd:dateTime</code></td> <td style="text-align:left;"><code>RDF.XSD.DateTime</code></td></tr> <tr><td style="text-align:left;"><code>xsd:dateTimeStamp</code></td> <td style="text-align:left;">❌</td></tr> <tr><td style="text-align:left;"><code>xsd:date</code></td> <td style="text-align:left;"><code>RDF.XSD.Date</code></td></tr> <tr><td style="text-align:left;"><code>xsd:time</code></td> <td style="text-align:left;"><code>RDF.XSD.Time</code></td></tr> <tr><td style="text-align:left;"><code>xsd:duration</code></td> <td style="text-align:left;">❌</td></tr> <tr><td style="text-align:left;"><code>xsd:dayTimeDuration</code></td> <td style="text-align:left;">❌</td></tr> <tr><td style="text-align:left;"><code>xsd:yearMonthDuration</code></td> <td style="text-align:left;">❌</td></tr> <tr><td style="text-align:left;"><code>xsd:gYearMonth</code></td> <td style="text-align:left;">❌</td></tr> <tr><td style="text-align:left;"><code>xsd:gYear</code></td> <td style="text-align:left;">❌</td></tr> <tr><td style="text-align:left;"><code>xsd:gMonthDay</code></td> <td style="text-align:left;">❌</td></tr> <tr><td style="text-align:left;"><code>xsd:gDay</code></td> <td style="text-align:left;">❌</td></tr> <tr><td style="text-align:left;"><code>xsd:gMonth</code></td> <td style="text-align:left;">❌</td></tr> <tr><td style="text-align:left;"><code>xsd:base64Binary</code></td> <td style="text-align:left;">❌</td></tr> <tr><td style="text-align:left;"><code>xsd:hexBinary</code></td> <td style="text-align:left;">❌</td></tr> <tr><td style="text-align:left;"><code>xsd:anyURI</code></td> <td style="text-align:left;"><code>RDF.XSD.AnyURI</code></td></tr> <tr><td style="text-align:left;"><code>xsd:QName</code></td> <td style="text-align:left;">❌</td></tr> <tr><td style="text-align:left;"><code>xsd:NOTATION</code></td> <td style="text-align:left;">❌</td></tr></tbody></table> <p>For literals with an unknown datatype, i.e. a datatype without a <code>RDF.Literal.Datatype</code> module the generic <code>RDF.Literal.Generic</code> implementation s used. For those generic literals the  <code>RDF.Literal.value/1</code> function simply returns the initially given value unvalidated and unconverted.</p> <h2 id="validation"><a href="#validation" aria-hidden="true" class="header-anchor">#</a> Validation</h2> <p>The <code>RDF.Literal.valid?/1</code> function checks if a given literal is valid according to the semantics in its <code>RDF.Literal.Datatype</code> implementation.</p> <div class="language-elixir extra-class"><pre class="language-elixir"><code>iex<span class="token operator">&gt;</span> RDF<span class="token punctuation">.</span>Literal<span class="token punctuation">.</span>valid? XSD<span class="token punctuation">.</span>integer<span class="token punctuation">(</span><span class="token string">&quot;42&quot;</span><span class="token punctuation">)</span>
<span class="token boolean">true</span>

iex<span class="token operator">&gt;</span> RDF<span class="token punctuation">.</span>Literal<span class="token punctuation">.</span>valid? XSD<span class="token punctuation">.</span>integer<span class="token punctuation">(</span><span class="token string">&quot;foo&quot;</span><span class="token punctuation">)</span>
<span class="token boolean">false</span>
</code></pre></div><p>Since the semantics of <code>RDF.Literal.Generic</code> literals is unknown they are always considered to be valid.</p> <p>If you want to prohibit the creation of invalid literals, you can use the <code>new!</code> constructor function of the <code>RDF.Literal.Datatype</code> or <code>RDF.Literal</code>, which will fail in case of invalid values.</p> <h2 id="lexical-and-canonical-form"><a href="#lexical-and-canonical-form" aria-hidden="true" class="header-anchor">#</a> Lexical and canonical form</h2> <p>A RDF literal is bound to the lexical form of the initially given value. This lexical representation can be retrieved with the <code>RDF.Literal.lexical/1</code> function:</p> <div class="language-elixir extra-class"><pre class="language-elixir"><code>iex<span class="token operator">&gt;</span> RDF<span class="token punctuation">.</span>Literal<span class="token punctuation">.</span>lexical XSD<span class="token punctuation">.</span>integer<span class="token punctuation">(</span><span class="token string">&quot;0042&quot;</span><span class="token punctuation">)</span>
<span class="token string">&quot;0042&quot;</span>

iex<span class="token operator">&gt;</span> RDF<span class="token punctuation">.</span>Literal<span class="token punctuation">.</span>lexical XSD<span class="token punctuation">.</span>integer<span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span>
<span class="token string">&quot;42&quot;</span>
</code></pre></div><p>The <code>RDF.Literal.canonical/1</code> function normalizes the given literal to the canonical lexical form according to its datatype:</p> <div class="language-elixir extra-class"><pre class="language-elixir"><code>iex<span class="token operator">&gt;</span> RDF<span class="token punctuation">.</span>integer<span class="token punctuation">(</span><span class="token string">&quot;0042&quot;</span><span class="token punctuation">)</span> <span class="token operator">|&gt;</span> RDF<span class="token punctuation">.</span>Literal<span class="token punctuation">.</span>canonical <span class="token operator">|&gt;</span> RDF<span class="token punctuation">.</span>Literal<span class="token punctuation">.</span>lexical
<span class="token string">&quot;42&quot;</span>

iex<span class="token operator">&gt;</span> RDF<span class="token punctuation">.</span>Literal<span class="token punctuation">.</span>canonical<span class="token punctuation">(</span>RDF<span class="token punctuation">.</span>integer<span class="token punctuation">(</span><span class="token string">&quot;0042&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> 
     RDF<span class="token punctuation">.</span>Literal<span class="token punctuation">.</span>canonical<span class="token punctuation">(</span>RDF<span class="token punctuation">.</span>integer<span class="token punctuation">(</span><span class="token string">&quot;42&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token boolean">true</span>
</code></pre></div><p>For <code>RDF.Literal.Generic</code> literals the <code>canonical</code> function returns the given literal unchanged.</p> <p>Since the canonical form is undefined for invalid literals, <code>nil</code> is returned in this case.</p> <p>If you're just interested in the canonical lexical form as a string you can also use the <code>RDF.Literal.canonical_lexical/1</code> function, which is also a bit faster, since the intermediary canonicalization is not needed.</p> <div class="language-elixir extra-class"><pre class="language-elixir"><code>iex<span class="token operator">&gt;</span> RDF<span class="token punctuation">.</span>Literal<span class="token punctuation">.</span>canonical_lexical XSD<span class="token punctuation">.</span>integer<span class="token punctuation">(</span><span class="token string">&quot;0042&quot;</span><span class="token punctuation">)</span>
<span class="token string">&quot;42&quot;</span>
</code></pre></div><h2 id="equivalence"><a href="#equivalence" aria-hidden="true" class="header-anchor">#</a> Equivalence</h2> <p>Although two literals might have the same value, they are not equal if they don't have the same lexical form:</p> <div class="language-elixir extra-class"><pre class="language-elixir"><code>iex<span class="token operator">&gt;</span> RDF<span class="token punctuation">.</span>Literal<span class="token punctuation">.</span>value<span class="token punctuation">(</span>XSD<span class="token punctuation">.</span>integer<span class="token punctuation">(</span><span class="token string">&quot;0042&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> RDF<span class="token punctuation">.</span>Literal<span class="token punctuation">.</span>value<span class="token punctuation">(</span>XSD<span class="token punctuation">.</span>integer<span class="token punctuation">(</span><span class="token string">&quot;42&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token boolean">true</span>

iex<span class="token operator">&gt;</span> XSD<span class="token punctuation">.</span>integer<span class="token punctuation">(</span><span class="token string">&quot;0042&quot;</span><span class="token punctuation">)</span> <span class="token operator">==</span> XSD<span class="token punctuation">.</span>integer<span class="token punctuation">(</span><span class="token string">&quot;42&quot;</span><span class="token punctuation">)</span>
<span class="token boolean">false</span>
</code></pre></div><p>The <code>RDF.Literal.equal_value?/2</code> function however, does a pure value-based equivalence comparison. It also takes into account compatibilities between different types, eg. derived datypes. Since it is the basis for the implementation of SPARQLs <code>=</code> operator in SPARQL.ex everything that is equivalent in terms of this operator will match. Literals which aren't comparable in general due to their type and would result in an error match in terms of the SPARQL <code>=</code> operator (meaning that also the negation wouldn't match) will return <code>nil</code>. Above this, it also coerces native Elixir values to <code>RDF.Literal</code>s before doing the comparison.</p> <div class="language-elixir extra-class"><pre class="language-elixir"><code>iex<span class="token operator">&gt;</span> XSD<span class="token punctuation">.</span>integer<span class="token punctuation">(</span><span class="token string">&quot;0042&quot;</span><span class="token punctuation">)</span> <span class="token operator">|&gt;</span> RDF<span class="token punctuation">.</span>Literal<span class="token punctuation">.</span>equal_value?<span class="token punctuation">(</span>XSD<span class="token punctuation">.</span>integer<span class="token punctuation">(</span><span class="token string">&quot;42&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token boolean">true</span>

iex<span class="token operator">&gt;</span> XSD<span class="token punctuation">.</span>integer<span class="token punctuation">(</span><span class="token string">&quot;0042&quot;</span><span class="token punctuation">)</span> <span class="token operator">|&gt;</span> RDF<span class="token punctuation">.</span>Literal<span class="token punctuation">.</span>equal_value?<span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span>
<span class="token boolean">true</span>

iex<span class="token operator">&gt;</span> XSD<span class="token punctuation">.</span>integer<span class="token punctuation">(</span><span class="token string">&quot;0042&quot;</span><span class="token punctuation">)</span> <span class="token operator">|&gt;</span> RDF<span class="token punctuation">.</span>Literal<span class="token punctuation">.</span>equal_value?<span class="token punctuation">(</span>XSD<span class="token punctuation">.</span>short<span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token boolean">true</span>

iex<span class="token operator">&gt;</span> XSD<span class="token punctuation">.</span>anyURI<span class="token punctuation">(</span><span class="token string">&quot;http://example.com&quot;</span><span class="token punctuation">)</span> <span class="token operator">|&gt;</span> RDF<span class="token punctuation">.</span>Literal<span class="token punctuation">.</span>equal_value?<span class="token punctuation">(</span>RDF<span class="token punctuation">.</span>iri<span class="token punctuation">(</span><span class="token string">&quot;http://example.com&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token boolean">true</span>

iex<span class="token operator">&gt;</span> XSD<span class="token punctuation">.</span>integer<span class="token punctuation">(</span><span class="token string">&quot;0042&quot;</span><span class="token punctuation">)</span> <span class="token operator">|&gt;</span> RDF<span class="token punctuation">.</span>Literal<span class="token punctuation">.</span>equal_value?<span class="token punctuation">(</span>XSD<span class="token punctuation">.</span>string<span class="token punctuation">(</span><span class="token string">&quot;42&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token boolean">nil</span>
</code></pre></div><h2 id="defining-custom-datatypes"><a href="#defining-custom-datatypes" aria-hidden="true" class="header-anchor">#</a> Defining custom datatypes</h2> <p>You can define your own custom datatype by implementing the <code>RDF.Literal.Datatype</code> behaviour. Defining a completely independent dataype however, will probably be the exception and goes beyond the scope of this introductary guide. Most of the time you want to introduce a custom datatype by constraining one of the existing XSD datatypes through datatype derivation.</p> <div class="danger custom-block"><p>It should be noted that a triple store won't know how to handle your custom datatype unless it's a well-known datatype he supports, so they should be introduced cautiously. But at least in the RDF.ex libraries they will behave like the predefined XSD datatypes. In particular you can apply the respective SPARQL functions within SPARQL.ex on them.</p></div> <p>So, a custom datatype can be derived from a XSD datatype (with an existing <code>RDF.Literal.Datatype</code> implementation) by defining a new module with <code>use RDF.XSD.Datatype.Restriction</code> and constraining its value space. RDF.ex implements most of the <a href="https://www.w3.org/TR/xmlschema-2/#rf-facets" target="_blank" rel="noopener noreferrer">XSD facets<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> as <code>RDF.XSD.Facet</code> modules for this:</p> <table><thead><tr><th style="text-align:left;">XSD facet</th> <th style="text-align:left;"><code>RDF.XSD.Facet</code></th></tr></thead> <tbody><tr><td style="text-align:left;">length</td> <td style="text-align:left;"><code>RDF.XSD.Facets.Length</code></td></tr> <tr><td style="text-align:left;">minLength</td> <td style="text-align:left;"><code>RDF.XSD.Facets.MinLength</code></td></tr> <tr><td style="text-align:left;">maxLength</td> <td style="text-align:left;"><code>RDF.XSD.Facets.MaxLength</code></td></tr> <tr><td style="text-align:left;">maxInclusive</td> <td style="text-align:left;"><code>RDF.XSD.Facets.MaxInclusive</code></td></tr> <tr><td style="text-align:left;">maxExclusive</td> <td style="text-align:left;"><code>RDF.XSD.Facets.MaxExclusive</code></td></tr> <tr><td style="text-align:left;">minInclusive</td> <td style="text-align:left;"><code>RDF.XSD.Facets.MinInclusive</code></td></tr> <tr><td style="text-align:left;">minExclusive</td> <td style="text-align:left;"><code>RDF.XSD.Facets.MinExclusive</code></td></tr> <tr><td style="text-align:left;">totalDigits</td> <td style="text-align:left;"><code>RDF.XSD.Facets.TotalDigits</code></td></tr> <tr><td style="text-align:left;">fractionDigits</td> <td style="text-align:left;"><code>RDF.XSD.Facets.FractionDigits</code></td></tr> <tr><td style="text-align:left;">explicitTimezone</td> <td style="text-align:left;"><code>RDF.XSD.Facets.ExplicitTimezone</code></td></tr> <tr><td style="text-align:left;">pattern</td> <td style="text-align:left;"><code>RDF.XSD.Facets.Pattern</code></td></tr> <tr><td style="text-align:left;">whiteSpace</td> <td style="text-align:left;">❌</td></tr> <tr><td style="text-align:left;">enumeration</td> <td style="text-align:left;">❌</td></tr> <tr><td style="text-align:left;">assertions</td> <td style="text-align:left;">❌</td></tr></tbody></table> <p>Within the body of a module using  <code>RDF.XSD.Datatype.Restriction</code> you can apply one or multiple of these facets with the <code>def_facet_constraint</code> macro and specifying a value for the facets. This table shows which facets can be applied on the primitive datatypes (and their derived datatypes):</p> <table><thead><tr><th style="text-align:left;">Primitive datatype</th> <th style="text-align:left;">Applicable facets</th></tr></thead> <tbody><tr><td style="text-align:left;">string</td> <td style="text-align:left;">length, maxLength, minLength, pattern</td></tr> <tr><td style="text-align:left;">boolean</td> <td style="text-align:left;">pattern</td></tr> <tr><td style="text-align:left;">float</td> <td style="text-align:left;">maxExclusive, maxInclusive, minExclusive, minInclusive, pattern</td></tr> <tr><td style="text-align:left;">double</td> <td style="text-align:left;">maxExclusive, maxInclusive, minExclusive, minInclusive, pattern</td></tr> <tr><td style="text-align:left;">decimal</td> <td style="text-align:left;">maxExclusive, maxInclusive, minExclusive, minInclusive, pattern, totalDigits, fractionDigits</td></tr> <tr><td style="text-align:left;">integer</td> <td style="text-align:left;">maxExclusive, maxInclusive, minExclusive, minInclusive, pattern, totalDigits</td></tr> <tr><td style="text-align:left;">duration</td> <td style="text-align:left;">maxExclusive, maxInclusive, minExclusive, minInclusive, pattern</td></tr> <tr><td style="text-align:left;">dateTime</td> <td style="text-align:left;">explicitTimezone, maxExclusive, maxInclusive, minExclusive, minInclusive, pattern</td></tr> <tr><td style="text-align:left;">time</td> <td style="text-align:left;">explicitTimezone, maxExclusive, maxInclusive, minExclusive, minInclusive, pattern</td></tr> <tr><td style="text-align:left;">date</td> <td style="text-align:left;">explicitTimezone, maxExclusive, maxInclusive, minExclusive, minInclusive, pattern</td></tr> <tr><td style="text-align:left;">anyURI</td> <td style="text-align:left;">length, maxLength, minLength, pattern</td></tr></tbody></table> <p>Let's see how a custom datatype for the age of a person could be defined in an application:</p> <div class="language-elixir extra-class"><pre class="language-elixir"><code><span class="token keyword">defmodule</span> MyApp<span class="token punctuation">.</span>PersonAge <span class="token keyword">do</span>
  <span class="token keyword">use</span> RDF<span class="token punctuation">.</span>XSD<span class="token punctuation">.</span>Datatype<span class="token punctuation">.</span>Restriction<span class="token punctuation">,</span>
      <span class="token attr-name">name:</span> <span class="token string">&quot;person_age&quot;</span><span class="token punctuation">,</span>
      <span class="token attr-name">id:</span> <span class="token string">&quot;http://example.com/person_age&quot;</span><span class="token punctuation">,</span>
      <span class="token attr-name">base:</span> RDF<span class="token punctuation">.</span>XSD<span class="token punctuation">.</span>NonNegativeInteger

  def_facet_constraint RDF<span class="token punctuation">.</span>XSD<span class="token punctuation">.</span>Facets<span class="token punctuation">.</span>MaxInclusive<span class="token punctuation">,</span> <span class="token number">150</span>
<span class="token keyword">end</span>
</code></pre></div><p>This datatype can now constructed by either its <code>new</code> constructor or via the generic typed  <code>RDF.Literal</code> constuctor and the specified datatype URI.</p> <div class="language-elixir extra-class"><pre class="language-elixir"><code>iex<span class="token operator">&gt;</span> MyApp<span class="token punctuation">.</span>PersonAge<span class="token punctuation">.</span>new<span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span>
<span class="token punctuation">%</span>RDF<span class="token punctuation">.</span>Literal<span class="token punctuation">{</span><span class="token attr-name">literal:</span> <span class="token punctuation">%</span>MyApp<span class="token punctuation">.</span>PersonAge<span class="token punctuation">{</span><span class="token attr-name">value:</span> <span class="token number">42</span><span class="token punctuation">,</span> <span class="token attr-name">lexical:</span> <span class="token string">&quot;42&quot;</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token attr-name">valid:</span> <span class="token boolean">true</span><span class="token punctuation">}</span>

iex<span class="token operator">&gt;</span> RDF<span class="token punctuation">.</span>literal<span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">,</span> <span class="token attr-name">datatype:</span> <span class="token string">&quot;http://example.com/person_age&quot;</span><span class="token punctuation">)</span>
<span class="token punctuation">%</span>RDF<span class="token punctuation">.</span>Literal<span class="token punctuation">{</span><span class="token attr-name">literal:</span> <span class="token punctuation">%</span>MyApp<span class="token punctuation">.</span>PersonAge<span class="token punctuation">{</span><span class="token attr-name">value:</span> <span class="token number">42</span><span class="token punctuation">,</span> <span class="token attr-name">lexical:</span> <span class="token string">&quot;42&quot;</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token attr-name">valid:</span> <span class="token boolean">true</span><span class="token punctuation">}</span>
</code></pre></div><p>Within RDF.ex and the libraries on top of it (SPARQL.ex, ShEx.ex) this datatype can be used wherever a <code>xsd:nonNegativeInteger</code> or <code>xsd:integer</code> is expected.</p> <div class="language-elixir extra-class"><pre class="language-elixir"><code>iex<span class="token operator">&gt;</span> XSD<span class="token punctuation">.</span>integer<span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span> <span class="token operator">|&gt;</span> RDF<span class="token punctuation">.</span>Literal<span class="token punctuation">.</span>equal_value?<span class="token punctuation">(</span>MyApp<span class="token punctuation">.</span>PersonAge<span class="token punctuation">.</span>new<span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token boolean">true</span>
</code></pre></div><h2 id="type-checking-and-reflection"><a href="#type-checking-and-reflection" aria-hidden="true" class="header-anchor">#</a> Type checking and reflection</h2> <p>The datatype IRI of any <code>RDF.Literal</code> can be retrieved with the <code>RDF.Literal.datatype_id/1</code> function.</p> <div class="language-elixir extra-class"><pre class="language-elixir"><code>iex<span class="token operator">&gt;</span> XSD<span class="token punctuation">.</span>integer<span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span> <span class="token operator">|&gt;</span> RDF<span class="token punctuation">.</span>Literal<span class="token punctuation">.</span>datatype_id<span class="token punctuation">(</span><span class="token punctuation">)</span>
~I<span class="token operator">&lt;</span><span class="token attr-name">http:</span><span class="token operator">/</span><span class="token operator">/</span>www<span class="token punctuation">.</span>w3<span class="token punctuation">.</span>org<span class="token operator">/</span><span class="token number">2001</span><span class="token operator">/</span>XMLSchema<span class="token comment">#integer&gt;</span>

iex<span class="token operator">&gt;</span> ~L<span class="token string">&quot;foo&quot;</span>en <span class="token operator">|&gt;</span> RDF<span class="token punctuation">.</span>Literal<span class="token punctuation">.</span>datatype_id<span class="token punctuation">(</span><span class="token punctuation">)</span>
~I<span class="token operator">&lt;</span><span class="token attr-name">http:</span><span class="token operator">/</span><span class="token operator">/</span>www<span class="token punctuation">.</span>w3<span class="token punctuation">.</span>org<span class="token operator">/</span><span class="token number">1999</span><span class="token operator">/</span><span class="token number">02</span><span class="token operator">/</span><span class="token number">22</span><span class="token operator">-</span>rdf<span class="token operator">-</span>syntax<span class="token operator">-</span>ns<span class="token comment">#langString&gt;</span>

iex<span class="token operator">&gt;</span> RDF<span class="token punctuation">.</span>literal<span class="token punctuation">(</span><span class="token string">&quot;foo&quot;</span><span class="token punctuation">,</span> <span class="token attr-name">datatype:</span> <span class="token string">&quot;http://example.com/dt&quot;</span><span class="token punctuation">)</span> <span class="token operator">|&gt;</span> RDF<span class="token punctuation">.</span>Literal<span class="token punctuation">.</span>datatype_id<span class="token punctuation">(</span><span class="token punctuation">)</span>
~I<span class="token operator">&lt;</span><span class="token attr-name">http:</span><span class="token operator">/</span><span class="token operator">/</span>example<span class="token punctuation">.</span>com<span class="token operator">/</span>dt<span class="token operator">&gt;</span>
</code></pre></div><p>Although you won't need this most of the time, since you can use all types of literals via the polymorphic <code>RDF.Literal</code> functions, the inverse operation is also possible. When a <code>RDF.Literal.Datatype</code> is defined for a datatype IRI, you can get the module dynamically by its IRI with the <code>RDF.Literal.Datatype.get/1</code> function.</p> <div class="language-elixir extra-class"><pre class="language-elixir"><code>iex<span class="token operator">&gt;</span> RDF<span class="token punctuation">.</span>Literal<span class="token punctuation">.</span>Datatype<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">&quot;http://www.w3.org/2001/XMLSchema#integer&quot;</span><span class="token punctuation">)</span>
RDF<span class="token punctuation">.</span>XSD<span class="token punctuation">.</span>Integer

iex<span class="token operator">&gt;</span> RDF<span class="token punctuation">.</span>Literal<span class="token punctuation">.</span>Datatype<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">&quot;http://example.com/custom/datatype&quot;</span><span class="token punctuation">)</span>
My<span class="token punctuation">.</span>Custom<span class="token punctuation">.</span>Datatype

<span class="token comment"># assuming there's no custom RDF.Literal.Datatype for http://example.com/dt defined</span>
iex<span class="token operator">&gt;</span> RDF<span class="token punctuation">.</span>Literal<span class="token punctuation">.</span>Datatype<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">&quot;http://example.com/dt&quot;</span><span class="token punctuation">)</span>
<span class="token boolean">nil</span>
</code></pre></div><p>An <code>RDF.Literal</code> with a datatype for which a <code>RDF.Literal.Datatype</code> is defined can be pattern matched via its <code>literal</code> field and the module implementing the <code>RDF.Literal.Datatype</code>.</p> <div class="language-elixir extra-class"><pre class="language-elixir"><code><span class="token keyword">def</span> fun<span class="token punctuation">(</span><span class="token punctuation">%</span>RDF<span class="token punctuation">.</span>Literal<span class="token punctuation">{</span><span class="token attr-name">literal:</span> <span class="token punctuation">%</span>XSD<span class="token punctuation">.</span>Integer<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span> <span class="token operator">=</span> integer_literal<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token attr-name">do:</span> <span class="token operator">...</span>

<span class="token keyword">def</span> fun<span class="token punctuation">(</span><span class="token punctuation">%</span>RDF<span class="token punctuation">.</span>Literal<span class="token punctuation">{</span><span class="token attr-name">literal:</span> <span class="token punctuation">%</span>My<span class="token punctuation">.</span>Custom<span class="token punctuation">.</span>Datatype<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span> <span class="token operator">=</span> my_literal<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token attr-name">do:</span> <span class="token operator">...</span>
</code></pre></div><p>Literals with a datatype for which no <code>RDF.Literal.Datatype</code> is defined can be pattern matched via the <code>datatype</code> of the <code>RDF.Literal.Generic</code> datatype.</p> <div class="language-elixir extra-class"><pre class="language-elixir"><code><span class="token comment"># assuming there's no custom RDF.Literal.Datatype for http://example.com/dt defined</span>
<span class="token keyword">def</span> fun<span class="token punctuation">(</span><span class="token punctuation">%</span>RDF<span class="token punctuation">.</span>Literal<span class="token punctuation">{</span><span class="token attr-name">literal:</span> <span class="token punctuation">%</span>RDF<span class="token punctuation">.</span>Literal<span class="token punctuation">.</span>Generic<span class="token punctuation">{</span><span class="token attr-name">datatype:</span> <span class="token string">&quot;http://example.com/dt&quot;</span><span class="token punctuation">}</span><span class="token punctuation">}</span> <span class="token operator">=</span> literal<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token attr-name">do:</span> <span class="token operator">...</span>
</code></pre></div><p>Although pattern matching is the most elegant way for type checks, this only allows for exact datatype matches. The <code>datatype?/1</code> functions on the individual <code>RDF.Literal.Datatype</code> modules are aware of derivations and check whether the datatype of a given literal is either the datatype for which the <code>RDF.Literal.Datatype</code> is defined or derived of this datatype.</p> <div class="language-elixir extra-class"><pre class="language-elixir"><code>iex<span class="token operator">&gt;</span> XSD<span class="token punctuation">.</span>integer<span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span> <span class="token operator">|&gt;</span> XSD<span class="token punctuation">.</span>Integer<span class="token punctuation">.</span>datatype?<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token boolean">true</span>

iex<span class="token operator">&gt;</span> XSD<span class="token punctuation">.</span>byte<span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span> <span class="token operator">|&gt;</span> XSD<span class="token punctuation">.</span>Integer<span class="token punctuation">.</span>datatype?<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token boolean">true</span>

iex<span class="token operator">&gt;</span> XSD<span class="token punctuation">.</span>byte<span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span> <span class="token operator">|&gt;</span> XSD<span class="token punctuation">.</span>UnsignedInteger<span class="token punctuation">.</span>datatype?<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token boolean">true</span>

iex<span class="token operator">&gt;</span> XSD<span class="token punctuation">.</span>byte<span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span> <span class="token operator">|&gt;</span> XSD<span class="token punctuation">.</span>NegativeInteger<span class="token punctuation">.</span>datatype?<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token boolean">false</span>

iex<span class="token operator">&gt;</span> XSD<span class="token punctuation">.</span>byte<span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span> <span class="token operator">|&gt;</span> XSD<span class="token punctuation">.</span>Decimal<span class="token punctuation">.</span>datatype?<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token attr-name">TODO:</span> ??? 

<span class="token comment"># assuming My.Custom.Datatype is derived from xsd:integer or one of its derived datatypes</span>
iex<span class="token operator">&gt;</span> My<span class="token punctuation">.</span>Custom<span class="token punctuation">.</span>Datatype<span class="token punctuation">.</span>new<span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span> <span class="token operator">|&gt;</span> XSD<span class="token punctuation">.</span>Integer<span class="token punctuation">.</span>datatype?<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token boolean">true</span>

<span class="token comment"># assuming there's a custom RDF.Literal.Datatype for http://example.com/dt defined and it is derived from a xsd:integer</span>
iex<span class="token operator">&gt;</span> RDF<span class="token punctuation">.</span>literal<span class="token punctuation">(</span><span class="token string">&quot;foo&quot;</span><span class="token punctuation">,</span> <span class="token attr-name">datatype:</span> <span class="token string">&quot;http://example.com/dt&quot;</span><span class="token punctuation">)</span> <span class="token operator">|&gt;</span> XSD<span class="token punctuation">.</span>Integer<span class="token punctuation">.</span>datatype?<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token boolean">true</span>
</code></pre></div><p>The <code>RDF.XSD.Numeric.datatype?/1</code> function can also be handy. It checks if the datatype of a literal is one of the numeric XSD datatypes or derived from one of them.</p> <div class="language-elixir extra-class"><pre class="language-elixir"><code>iex<span class="token operator">&gt;</span> XSD<span class="token punctuation">.</span>integer<span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span> <span class="token operator">|&gt;</span> XSD<span class="token punctuation">.</span>Numeric<span class="token punctuation">.</span>datatype?<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token boolean">true</span>

iex<span class="token operator">&gt;</span> XSD<span class="token punctuation">.</span>string<span class="token punctuation">(</span><span class="token string">&quot;foo&quot;</span><span class="token punctuation">)</span> <span class="token operator">|&gt;</span> XSD<span class="token punctuation">.</span>Numeric<span class="token punctuation">.</span>datatype?<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token boolean">false</span>

<span class="token comment"># assuming My.Custom.Datatype is derived from a numeric XSD datatype</span>
iex<span class="token operator">&gt;</span> My<span class="token punctuation">.</span>Custom<span class="token punctuation">.</span>Datatype<span class="token punctuation">.</span>new<span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span> <span class="token operator">|&gt;</span> XSD<span class="token punctuation">.</span>Numeric<span class="token punctuation">.</span>datatype?<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token boolean">true</span>

<span class="token comment"># assuming there's no custom RDF.Literal.Datatype for http://example.com/dt defined or it is not derived from a numeric XSD datatype</span>
iex<span class="token operator">&gt;</span> RDF<span class="token punctuation">.</span>literal<span class="token punctuation">(</span><span class="token string">&quot;foo&quot;</span><span class="token punctuation">,</span> <span class="token attr-name">datatype:</span> <span class="token string">&quot;http://example.com/dt&quot;</span><span class="token punctuation">)</span> <span class="token operator">|&gt;</span> XSD<span class="token punctuation">.</span>Numeric<span class="token punctuation">.</span>datatype?<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token boolean">false</span>
</code></pre></div><p>The general purpose type check function <code>RDF.Literal.is_a?/2</code> supports all of these <code>datatype?/1</code> functions</p> <div class="language-elixir extra-class"><pre class="language-elixir"><code>iex<span class="token operator">&gt;</span> XSD<span class="token punctuation">.</span>byte<span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span> <span class="token operator">|&gt;</span> RDF<span class="token punctuation">.</span>Literal<span class="token punctuation">.</span>is_a?<span class="token punctuation">(</span>XSD<span class="token punctuation">.</span>Byte<span class="token punctuation">)</span>
<span class="token boolean">true</span>

iex<span class="token operator">&gt;</span> XSD<span class="token punctuation">.</span>byte<span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span> <span class="token operator">|&gt;</span> RDF<span class="token punctuation">.</span>Literal<span class="token punctuation">.</span>is_a?<span class="token punctuation">(</span>XSD<span class="token punctuation">.</span>Integer<span class="token punctuation">)</span>
<span class="token boolean">true</span>

iex<span class="token operator">&gt;</span> XSD<span class="token punctuation">.</span>byte<span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span> <span class="token operator">|&gt;</span> RDF<span class="token punctuation">.</span>Literal<span class="token punctuation">.</span>is_a?<span class="token punctuation">(</span>XSD<span class="token punctuation">.</span>Numeric<span class="token punctuation">)</span>
<span class="token boolean">true</span>

iex<span class="token operator">&gt;</span> XSD<span class="token punctuation">.</span>byte<span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span> <span class="token operator">|&gt;</span> RDF<span class="token punctuation">.</span>Literal<span class="token punctuation">.</span>is_a?<span class="token punctuation">(</span>XSD<span class="token punctuation">.</span>Datatype<span class="token punctuation">)</span>
<span class="token boolean">true</span>

iex<span class="token operator">&gt;</span> RDF<span class="token punctuation">.</span>langString<span class="token punctuation">(</span><span class="token string">&quot;foo&quot;</span><span class="token punctuation">,</span> <span class="token attr-name">language:</span> <span class="token string">&quot;en&quot;</span><span class="token punctuation">)</span> <span class="token operator">|&gt;</span> RDF<span class="token punctuation">.</span>Literal<span class="token punctuation">.</span>is_a?<span class="token punctuation">(</span>XSD<span class="token punctuation">.</span>Datatype<span class="token punctuation">)</span>
<span class="token boolean">false</span>

<span class="token comment"># assuming there's no custom RDF.Literal.Datatype for http://example.com/dt</span>
iex<span class="token operator">&gt;</span> RDF<span class="token punctuation">.</span>literal<span class="token punctuation">(</span><span class="token string">&quot;foo&quot;</span><span class="token punctuation">,</span> <span class="token attr-name">datatype:</span> <span class="token string">&quot;http://example.com/dt&quot;</span><span class="token punctuation">)</span> <span class="token operator">|&gt;</span> RDF<span class="token punctuation">.</span>Literal<span class="token punctuation">.</span>is_a?<span class="token punctuation">(</span>RDF<span class="token punctuation">.</span>Literal<span class="token punctuation">.</span>Generic<span class="token punctuation">)</span>
<span class="token boolean">true</span>
</code></pre></div><p>Most of the functions on the <code>RDF.Literal.Datatype</code> modules are only applicable on literals of exact this datatype, but there are two notable exceptions which can be handy.</p> <p>The <code>valid?/1</code> function on <code>RDF.Literal.Datatype</code> modules is able to deal with derived datatypes and returns <code>true</code> if the given literal is valid AND of the proper type.</p> <div class="language-elixir extra-class"><pre class="language-elixir"><code>iex<span class="token operator">&gt;</span> XSD<span class="token punctuation">.</span>byte<span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span> <span class="token operator">|&gt;</span> XSD<span class="token punctuation">.</span>Integer<span class="token punctuation">.</span>valid?<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token boolean">true</span>

iex<span class="token operator">&gt;</span> XSD<span class="token punctuation">.</span>float<span class="token punctuation">(</span><span class="token number">3.14</span><span class="token punctuation">)</span> <span class="token operator">|&gt;</span> XSD<span class="token punctuation">.</span>Integer<span class="token punctuation">.</span>valid?<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token boolean">false</span>
</code></pre></div><p>The <code>value/1</code> function on the <code>RDF.Literal.Datatype</code> modules also returns the value of literals when they are of a derived datatype (or <code>nil</code> if the datatype is not derived from this datatype.</p> <div class="language-elixir extra-class"><pre class="language-elixir"><code>iex<span class="token operator">&gt;</span> XSD<span class="token punctuation">.</span>byte<span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span> <span class="token operator">|&gt;</span> XSD<span class="token punctuation">.</span>Integer<span class="token punctuation">.</span>value<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token number">42</span>

iex<span class="token operator">&gt;</span> XSD<span class="token punctuation">.</span>float<span class="token punctuation">(</span><span class="token number">3.14</span><span class="token punctuation">)</span> <span class="token operator">|&gt;</span> XSD<span class="token punctuation">.</span>Integer<span class="token punctuation">.</span>value<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token boolean">nil</span>
</code></pre></div></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/rdf-elixir/website/edit/master/content/rdf-ex/literals.md" target="_blank" rel="noopener noreferrer">Edit this page</a> <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></div> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/rdf-ex/blank-nodes.html" class="prev">
          Blank nodes
        </a></span> <span class="next"><a href="/rdf-ex/statements.html">
          Statements
        </a>
        →
      </span></p></div> </main></div><div class="global-ui"><!----><!----></div></div>
    <script src="/assets/js/app.9947d21f.js" defer></script><script src="/assets/js/2.9c83fda1.js" defer></script><script src="/assets/js/22.3ae550ed.js" defer></script><script src="/assets/js/3.6456fe17.js" defer></script>
  </body>
</html>
