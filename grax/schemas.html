<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Schemas | RDF on Elixir</title>
    <meta name="description" content="Implementation of the Linked Data and Semantic Standards for Elixir">
    <link rel="manifest" href="/icons/manifest.json">
  <link rel="icon" type="image/x-icon" sizes="16x16 32x32" href="/icons/favicon.ico">
  <link rel="icon" sizes="192x192" href="/icons/favicon-192.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/favicon-180-precomposed.png">
  <meta name="msapplication-TileImage" content="/icons/favicon-144.png">
  <meta name="msapplication-TileColor" content="#FFFFFF">
  <meta name="theme-color" content="#3eaf7c">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
    
    <link rel="preload" href="/assets/css/0.styles.26047e9a.css" as="style"><link rel="preload" href="/assets/js/app.9947d21f.js" as="script"><link rel="preload" href="/assets/js/2.9c83fda1.js" as="script"><link rel="preload" href="/assets/js/14.16bc6703.js" as="script"><link rel="preload" href="/assets/js/3.6456fe17.js" as="script"><link rel="prefetch" href="/assets/js/10.ee4ed3c6.js"><link rel="prefetch" href="/assets/js/11.467615b9.js"><link rel="prefetch" href="/assets/js/12.6022d75e.js"><link rel="prefetch" href="/assets/js/13.b74f4730.js"><link rel="prefetch" href="/assets/js/15.b2a2c70a.js"><link rel="prefetch" href="/assets/js/16.16aff3dd.js"><link rel="prefetch" href="/assets/js/17.e92fb19a.js"><link rel="prefetch" href="/assets/js/18.029f34a1.js"><link rel="prefetch" href="/assets/js/19.05cb4c74.js"><link rel="prefetch" href="/assets/js/20.269187c7.js"><link rel="prefetch" href="/assets/js/21.bb8ba48a.js"><link rel="prefetch" href="/assets/js/22.3ae550ed.js"><link rel="prefetch" href="/assets/js/23.fd1aa42f.js"><link rel="prefetch" href="/assets/js/24.da208f76.js"><link rel="prefetch" href="/assets/js/25.0da14ab4.js"><link rel="prefetch" href="/assets/js/26.db8227de.js"><link rel="prefetch" href="/assets/js/27.4c9e9654.js"><link rel="prefetch" href="/assets/js/28.54a222e6.js"><link rel="prefetch" href="/assets/js/29.bf2a75a3.js"><link rel="prefetch" href="/assets/js/30.1a834a5c.js"><link rel="prefetch" href="/assets/js/31.e898f5f2.js"><link rel="prefetch" href="/assets/js/32.1235ec14.js"><link rel="prefetch" href="/assets/js/33.abbed48e.js"><link rel="prefetch" href="/assets/js/34.4b01380f.js"><link rel="prefetch" href="/assets/js/35.3d8d8b6b.js"><link rel="prefetch" href="/assets/js/36.6466eb8a.js"><link rel="prefetch" href="/assets/js/37.d63216a3.js"><link rel="prefetch" href="/assets/js/38.5f244a36.js"><link rel="prefetch" href="/assets/js/39.292a3e39.js"><link rel="prefetch" href="/assets/js/4.54ba1511.js"><link rel="prefetch" href="/assets/js/40.feb4961e.js"><link rel="prefetch" href="/assets/js/5.d4e734fc.js"><link rel="prefetch" href="/assets/js/6.dd985d23.js"><link rel="prefetch" href="/assets/js/7.98d61040.js"><link rel="prefetch" href="/assets/js/8.86f42866.js"><link rel="prefetch" href="/assets/js/9.5dff1e2d.js">
    <link rel="stylesheet" href="/assets/css/0.styles.26047e9a.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">RDF on Elixir</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/rdf-ex/" class="nav-link">RDF.ex</a></div><div class="nav-item"><a href="/sparql-ex/" class="nav-link">SPARQL.ex</a></div><div class="nav-item"><a href="/shex-ex/" class="nav-link">ShEx.ex</a></div><div class="nav-item"><a href="/grax/" class="nav-link router-link-active">Grax</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">API Documentation</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://hexdocs.pm/rdf/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  RDF.ex
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="https://hexdocs.pm/sparql/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  SPARQL.ex
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="https://hexdocs.pm/sparql_client/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  SPARQL.Client
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="https://hexdocs.pm/shex/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  ShEx.ex
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="https://hexdocs.pm/json_ld/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  JSON-LD.ex
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="https://hexdocs.pm/rdf_xml/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  RDF-XML.ex
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div></div><div class="nav-item"><a href="/links.html" class="nav-link">Links</a></div> <a href="https://github.com/rdf-elixir/website" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/rdf-ex/" class="nav-link">RDF.ex</a></div><div class="nav-item"><a href="/sparql-ex/" class="nav-link">SPARQL.ex</a></div><div class="nav-item"><a href="/shex-ex/" class="nav-link">ShEx.ex</a></div><div class="nav-item"><a href="/grax/" class="nav-link router-link-active">Grax</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">API Documentation</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://hexdocs.pm/rdf/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  RDF.ex
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="https://hexdocs.pm/sparql/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  SPARQL.ex
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="https://hexdocs.pm/sparql_client/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  SPARQL.Client
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="https://hexdocs.pm/shex/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  ShEx.ex
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="https://hexdocs.pm/json_ld/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  JSON-LD.ex
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="https://hexdocs.pm/rdf_xml/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  RDF-XML.ex
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div></div><div class="nav-item"><a href="/links.html" class="nav-link">Links</a></div> <a href="https://github.com/rdf-elixir/website" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>Grax</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/grax/" class="sidebar-link">Introduction</a></li><li><a href="/grax/installation.html" class="sidebar-link">Installation</a></li><li><a href="/grax/schemas.html" class="active sidebar-link">Schemas</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/grax/schemas.html#data-properties" class="sidebar-link">Data properties</a></li><li class="sidebar-sub-header"><a href="/grax/schemas.html#link-properties" class="sidebar-link">Link properties</a></li><li class="sidebar-sub-header"><a href="/grax/schemas.html#cardinalities" class="sidebar-link">Cardinalities</a></li><li class="sidebar-sub-header"><a href="/grax/schemas.html#class-declarations" class="sidebar-link">Class declarations</a></li><li class="sidebar-sub-header"><a href="/grax/schemas.html#schema-inheritance" class="sidebar-link">Schema inheritance</a></li><li class="sidebar-sub-header"><a href="/grax/schemas.html#custom-fields" class="sidebar-link">Custom fields</a></li><li class="sidebar-sub-header"><a href="/grax/schemas.html#custom-mappings" class="sidebar-link">Custom mappings</a></li></ul></li><li><a href="/grax/api.html" class="sidebar-link">API</a></li><li><a href="/grax/ids.html" class="sidebar-link">Ids</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="schemas"><a href="#schemas" aria-hidden="true" class="header-anchor">#</a> Schemas</h1> <p>A <strong><em>Grax schema</em></strong> is just an Elixir struct. In a traditional application, backed by a relational data model, you want to work with Elixir structs with the values from the relational database. You'll probably do this traditionally in Elixir with Ecto, by defining some <code>Ecto.Schema</code>s for the domain entities of your business. <code>Grax.Schema</code>s are similar to <code>Ecto.Schema</code>s, they both map the data to Elixir structs with some semantics on top of them, like a type system etc.</p> <p>But while Ecto maps data from relational databases, Grax maps data from graph databases to Elixir structs. Graph databases are based on the graph data model, which has less technical friction between the conceptual model of the humans and the data model for the machine as it is perfectly <a href="https://youtu.be/cHXbYLNa0qQ?t=290" target="_blank" rel="noopener noreferrer">demonstrated here<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>. By reducing the barrier between your conceptual models and the data models for your application, you have less to think about technical details and can spend more time on thinking about the actual domain model of the business problems your application has to solve.
You might have already got a feel of this, when working with GraphQL, where you simply define the nested schemas of a tree.</p> <p>How does a <code>Grax.Schema</code> definition look like? As an example, let's assume we have an RDF graph like this, which we want to map to Elixir structs with Elixir values for an Elixir application:</p> <div class="language- extra-class"><pre class="language-text"><code>@prefix : &lt;http://example.com/&gt; .
@prefix schema: &lt;https://schema.org/&gt; .
@prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt; .

:User1 
    a schema:Person, :PremiumUser ;
    schema:name &quot;Jane&quot; ;
    schema:email &quot;jane@example.com&quot;, &quot;jane@work.com&quot; ;
    foaf:age 30 ;
    schema:address [
      schema:addressCountry &quot;de&quot;
      schema:addressLocality &quot;Berlin&quot;
    ] .

:Post1
    schema:name &quot;Lorem&quot; ;
    schema:author :User1 ;
    schema:articleBody &quot;&quot;&quot;Lorem ipsum dolor sit amet, consectetur adipisicing elit. Provident, nihil, dignissimos. Nesciunt aut totam eius. Magnam quaerat modi vel sed, ipsam atque rem, eos vero ducimus beatae harum explicabo labore!&quot;&quot;&quot; .
</code></pre></div><p>A Grax schema struct for the <code>User</code> model of an application on this type of data could be defined with the <code>schema/1</code> macro of the <code>Grax.Schema</code> module like this:</p> <div class="language-elixir extra-class"><pre class="language-elixir"><code><span class="token keyword">defmodule</span> User <span class="token keyword">do</span>
  <span class="token keyword">use</span> Grax<span class="token punctuation">.</span>Schema

  schema <span class="token keyword">do</span>
    <span class="token comment"># ...</span>
  <span class="token keyword">end</span>
<span class="token keyword">end</span>
</code></pre></div><p>This will define a struct on the <code>User</code> module. Although this struct doesn't have any user-defined fields for the domain model of our application yet, this could already represent an RDF graph node, since every <code>Grax.Schema</code> struct has at least an internal <code>__id__</code>  field, which contains the <code>RDF.IRI</code> or <code>RDF.BlankNode</code>, mapping to a graph node. So, an instance of this struct would look like this:</p> <div class="language-elixir extra-class"><pre class="language-elixir"><code><span class="token keyword">alias</span> NS<span class="token punctuation">.</span>EX

<span class="token punctuation">%</span>User<span class="token punctuation">{</span><span class="token attr-name">__id__:</span> RDF<span class="token punctuation">.</span>iri<span class="token punctuation">(</span>EX<span class="token punctuation">.</span>User1<span class="token punctuation">)</span><span class="token punctuation">}</span>
<span class="token punctuation">%</span>Address<span class="token punctuation">{</span><span class="token attr-name">__id__:</span> ~B<span class="token operator">&lt;</span>Address1<span class="token operator">&gt;</span><span class="token punctuation">}</span>
</code></pre></div><p>These structs from RDF.ex are the only RDF-related values you'll see in a Grax schema struct. The <code>__id__</code> field should be treated similarly as the internal <code>__struct__</code> field of Elixir structs: use it maybe for pattern matching, but don't touch it directly (other than via functions exposed by the API).</p> <div class="tip custom-block"><p>The <code>schema</code> macro can be considered equal to a <code>defstruct</code> in that it allows to define every struct which can be defined with it. Under the hood it will produce the <code>defstruct</code> call as the first line of the generated code, which means you can use all types of annotations before the <code>schema</code> macro that can be used before a <code>defstruct</code>, eg. <code>@derive</code> annotations etc.</p></div> <p>But without any fields this isn't very interesting.</p> <h3 id="properties"><a href="#properties" aria-hidden="true" class="header-anchor">#</a> Properties</h3> <p>As opposed to the term &quot;field&quot; used for the elements of Elixir structs and <code>Ecto.Schema</code>s, we are calling the elements of the <code>Grax.Schema</code> struct <strong><em>properties</em></strong>, because we're mapping them to RDF properties. Unlike for fields of an Ecto schema, we'll not just have to provide a name atom for our property fields, but also a URI for the RDF property.</p> <p>So, a property definition on a Grax schema is done in the body of a <code>schema/1</code> block with the <code>property/3</code> macro and the property field name and a RDF property URI as the first two arguments.</p> <div class="language-elixir extra-class"><pre class="language-elixir"><code><span class="token keyword">defmodule</span> User <span class="token keyword">do</span>
  <span class="token keyword">use</span> Grax<span class="token punctuation">.</span>Schema

  schema <span class="token keyword">do</span>
    property <span class="token atom symbol">:name</span><span class="token punctuation">,</span> ~I<span class="token operator">&lt;</span><span class="token attr-name">http:</span><span class="token operator">/</span><span class="token operator">/</span>example<span class="token punctuation">.</span>com<span class="token operator">/</span>property<span class="token operator">&gt;</span>
  <span class="token keyword">end</span>
<span class="token keyword">end</span>
</code></pre></div><p>This will add an additional field on the Grax schema struct with the given name. The URI of the RDF property will be backed into the Grax schema struct. You won't have to deal with the URIs of the RDF properties furthermore. It will be automatically used for the mapping from and to RDF.</p> <p>The URI can be given in any form the <code>RDF.IRI.new/1</code> constructor of RDF.ex can create IRIs from, including IRIs directly (eg. via IRI sigils), strings or terms from an RDF.ex vocabulary namespace.</p> <div class="language-elixir extra-class"><pre class="language-elixir"><code><span class="token keyword">defmodule</span> User <span class="token keyword">do</span>
  <span class="token keyword">use</span> Grax<span class="token punctuation">.</span>Schema

  <span class="token keyword">alias</span> NS<span class="token punctuation">.</span>SchemaOrg

  schema <span class="token keyword">do</span>
    property <span class="token atom symbol">:name</span><span class="token punctuation">,</span> SchemaOrg<span class="token punctuation">.</span>name
  <span class="token keyword">end</span>
<span class="token keyword">end</span>
</code></pre></div><div class="warning custom-block"><p>We'll constantly use terms from RDF.ex vocabulary namespaces. These are modules and functions on these modules, which can be used instead of URIs in the Elixir code. If you're new to RDF.ex, you can read more about this <a href="/rdf-ex/vocabularies">here</a>.</p></div> <p>You can also define properties in a more concise form with the <code>property/1</code> macro:</p> <div class="language-elixir extra-class"><pre class="language-elixir"><code><span class="token keyword">defmodule</span> Example <span class="token keyword">do</span>
  <span class="token keyword">use</span> Grax<span class="token punctuation">.</span>Schema

  <span class="token keyword">alias</span> NS<span class="token punctuation">.</span>SchemaOrg

  schema <span class="token keyword">do</span>
    property <span class="token attr-name">name:</span> SchemaOrg<span class="token punctuation">.</span>name
  <span class="token keyword">end</span>
<span class="token keyword">end</span>
</code></pre></div><p>In this form the first keyword list element has this special meaning of a field name to property URI pair.</p> <p>All of these definition forms lead to structs like this:</p> <div class="language-elixir extra-class"><pre class="language-elixir"><code><span class="token punctuation">%</span>User<span class="token punctuation">{</span>
  <span class="token attr-name">__id__:</span> RDF<span class="token punctuation">.</span>iri<span class="token punctuation">(</span>EX<span class="token punctuation">.</span>User1<span class="token punctuation">)</span><span class="token punctuation">,</span> 
  <span class="token attr-name">name:</span> <span class="token string">&quot;Jane&quot;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>The property is accessible as a usual field name of the struct, but has an exact RDF interpretation implicitly through the internal mapping to an RDF property identifier. These minimal forms without any further type specifications are already valid property definitions in Grax. Unlike an Ecto schema, where every field requires a type, for a Grax schema the types are optional, just as RDF and most other graph models are at its core schema-free data models with optional types later on.</p> <p>But before we bring types into the game, we'll have to differentiate two general kinds of properties:</p> <ol><li><strong><em>Data properties</em></strong>, whose values we want to map to simple Elixir values, like strings and integers etc.</li> <li><strong><em>Link properties</em></strong> (the <em>object properties</em> of OWL), whose IRI or blank node values should be mapped to recursively nested <code>Grax.Schema</code> structs.</li></ol> <p>Despite having very different kinds of values, there's one type dichotomy across both kinds of properties. We can have single values or sets of values.</p> <p>By default it is assumed that the value of every property is unique, unless specified otherwise. If multiple values are allowed, a list type can be specified with the <code>list_of</code> type constructor function, which expects the type of its elements. The values will then be kept in a list accordingly. If you want to specify that a property can have multiple values of any datatype you can use the <code>list</code> function.</p> <p>With that we can extend our example mapping schema like this:</p> <div class="language-elixir extra-class"><pre class="language-elixir"><code><span class="token keyword">defmodule</span> User <span class="token keyword">do</span>
  <span class="token keyword">use</span> Grax<span class="token punctuation">.</span>Schema

  <span class="token keyword">alias</span> NS<span class="token punctuation">.</span><span class="token punctuation">{</span>SchemaOrg<span class="token punctuation">,</span> FOAF<span class="token punctuation">}</span>

  schema <span class="token keyword">do</span>
    property <span class="token atom symbol">:name</span><span class="token punctuation">,</span> SchemaOrg<span class="token punctuation">.</span>name<span class="token punctuation">,</span> <span class="token attr-name">type:</span> <span class="token atom symbol">:string</span>
    property <span class="token atom symbol">:emails</span><span class="token punctuation">,</span> SchemaOrg<span class="token punctuation">.</span>email<span class="token punctuation">,</span> <span class="token attr-name">type:</span> list_of<span class="token punctuation">(</span><span class="token atom symbol">:string</span><span class="token punctuation">)</span>
  <span class="token keyword">end</span>
<span class="token keyword">end</span>
</code></pre></div><p>Both email addresses from our example can now be represented in our <code>User</code> struct:</p> <div class="language-elixir extra-class"><pre class="language-elixir"><code><span class="token punctuation">%</span>User<span class="token punctuation">{</span>
  <span class="token attr-name">__id__:</span> RDF<span class="token punctuation">.</span>iri<span class="token punctuation">(</span>EX<span class="token punctuation">.</span>User1<span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token attr-name">name:</span> <span class="token string">&quot;Jane&quot;</span><span class="token punctuation">,</span>
  <span class="token attr-name">emails:</span> <span class="token punctuation">[</span><span class="token string">&quot;jane@example.com&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;jane@work.com&quot;</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="warning custom-block"><p>Although ordered lists are used for multiple values, the order is irrelevant since the values have no particular order in RDF. You should not rely on any particalur order. Similarly, as the values are essentially sets, duplicates are not allowed. They will be removed automatically.</p></div> <h2 id="data-properties"><a href="#data-properties" aria-hidden="true" class="header-anchor">#</a> Data properties</h2> <h3 id="datatypes"><a href="#datatypes" aria-hidden="true" class="header-anchor">#</a> Datatypes</h3> <p>The optional type specifications on our two kinds of properties are fundamentally different. The types of data properties defined with the <code>property</code> macros can be specified by providing the name of a datatype with the <code>:type</code> keyword.</p> <div class="language-elixir extra-class"><pre class="language-elixir"><code><span class="token keyword">defmodule</span> User <span class="token keyword">do</span>
  <span class="token keyword">use</span> Grax<span class="token punctuation">.</span>Schema

  <span class="token keyword">alias</span> NS<span class="token punctuation">.</span><span class="token punctuation">{</span>SchemaOrg<span class="token punctuation">,</span> FOAF<span class="token punctuation">}</span>

  schema <span class="token keyword">do</span>
    property <span class="token atom symbol">:name</span><span class="token punctuation">,</span> SchemaOrg<span class="token punctuation">.</span>name<span class="token punctuation">,</span> <span class="token attr-name">type:</span> <span class="token atom symbol">:string</span>
    property <span class="token atom symbol">:emails</span><span class="token punctuation">,</span> SchemaOrg<span class="token punctuation">.</span>email<span class="token punctuation">,</span> <span class="token attr-name">type:</span> list_of<span class="token punctuation">(</span><span class="token atom symbol">:string</span><span class="token punctuation">)</span>
    property <span class="token atom symbol">:age</span><span class="token punctuation">,</span> FOAF<span class="token punctuation">.</span>age<span class="token punctuation">,</span> <span class="token attr-name">type:</span> <span class="token atom symbol">:integer</span>
  <span class="token keyword">end</span>
<span class="token keyword">end</span>
</code></pre></div><p>The specified datatype defines what value a data property can have and which RDF datatype the produced literals for the RDF property should have.
The functions for working with these structs will validate these type definitions as described in the <a href="/grax/api">Grax API section</a>.</p> <p>The <code>User</code> structs now look like this:</p> <div class="language-elixir extra-class"><pre class="language-elixir"><code><span class="token punctuation">%</span>User<span class="token punctuation">{</span>
  <span class="token attr-name">__id__:</span> RDF<span class="token punctuation">.</span>iri<span class="token punctuation">(</span>EX<span class="token punctuation">.</span>User1<span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token attr-name">name:</span> <span class="token string">&quot;Jane&quot;</span><span class="token punctuation">,</span>
  <span class="token attr-name">emails:</span> <span class="token punctuation">[</span><span class="token string">&quot;jane@example.com&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;jane@work.com&quot;</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token attr-name">age:</span> <span class="token number">30</span>
<span class="token punctuation">}</span>
</code></pre></div><p>The types are given as atoms which correspond to the respective RDF.ex literal datatypes. Since RDF.ex implements the main parts of the XSD datatype system, a fairly rich set of types of values is type-derivation-aware available.</p> <table><thead><tr><th>Grax datatype</th> <th>RDF.ex literal datatype</th></tr></thead> <tbody><tr><td><code>:any_uri</code></td> <td><code>RDF.XSD.AnyURI</code></td></tr> <tr><td><code>:base64_binary</code></td> <td><code>RDF.XSD.Base64Binary</code></td></tr> <tr><td><code>:boolean</code></td> <td><code>RDF.XSD.Boolean</code></td></tr> <tr><td><code>:byte</code></td> <td><code>RDF.XSD.Byte</code></td></tr> <tr><td><code>:date</code></td> <td><code>RDF.XSD.Date</code></td></tr> <tr><td><code>:date_time</code></td> <td><code>RDF.XSD.DateTime</code></td></tr> <tr><td><code>:decimal</code></td> <td><code>RDF.XSD.Decimal</code></td></tr> <tr><td><code>:double</code></td> <td><code>RDF.XSD.Double</code></td></tr> <tr><td><code>:float</code></td> <td><code>RDF.XSD.Float</code></td></tr> <tr><td><code>:int</code></td> <td><code>RDF.XSD.Int</code></td></tr> <tr><td><code>:integer</code></td> <td><code>RDF.XSD.Integer</code></td></tr> <tr><td><code>:long</code></td> <td><code>RDF.XSD.Long</code></td></tr> <tr><td><code>:negative_integer</code></td> <td><code>RDF.XSD.NegativeInteger</code></td></tr> <tr><td><code>:non_negative_integer</code></td> <td><code>RDF.XSD.NonNegativeInteger</code></td></tr> <tr><td><code>:non_positive_integer</code></td> <td><code>RDF.XSD.NonPositiveInteger</code></td></tr> <tr><td><code>:positive_integer</code></td> <td><code>RDF.XSD.PositiveInteger</code></td></tr> <tr><td><code>:short</code></td> <td><code>RDF.XSD.Short</code></td></tr> <tr><td><code>:string</code></td> <td><code>RDF.XSD.String</code></td></tr> <tr><td><code>:time</code></td> <td><code>RDF.XSD.Time</code></td></tr> <tr><td><code>:unsigned_byte</code></td> <td><code>RDF.XSD.UnsignedByte</code></td></tr> <tr><td><code>:unsigned_int</code></td> <td><code>RDF.XSD.UnsignedInt</code></td></tr> <tr><td><code>:unsigned_long</code></td> <td><code>RDF.XSD.UnsignedLong</code></td></tr> <tr><td><code>:unsigned_short</code></td> <td><code>RDF.XSD.UnsignedShort</code></td></tr></tbody></table> <div class="warning custom-block"><p>The XSD date and time datatypes support also optional timezones, which are not supported by Elixir's <code>Date</code> and <code>Time</code> structs. Such date and time values with timezones are represented as tuples consisting of the <code>Date</code> and <code>Time</code> struct value and a string with the timezone, such as <code>{~D[2020-12-24], &quot;+01:00&quot;}</code> or <code>{~T[00:00:00], &quot;Z&quot;}</code>.</p></div> <p>Above these there are a couple of special datatypes:</p> <ul><li><p>The <code>:any</code> datatype is the default when no datatype is specified with the <code>:type</code> keyword or is assumed for the the elements when using the <code>list</code> type constructor function. It means the property can contain values of any datatype. The datatype mapping from Elixir values to XSD datatypes as described in <a href="/rdf-ex/literals.html#typed-literals">the table here</a> is applied in this case.</p></li> <li><p>The <code>:numeric</code> datatype behaves similar to the <code>:any</code> datatype, but limits the values to those of numeric datatypes.</p></li> <li><p>The <code>:iri</code> datatype can be used if IRIs should be kept as they are, which is useful when they shouldn't be mapped to nested mapping structs.</p></li></ul> <h3 id="default-values"><a href="#default-values" aria-hidden="true" class="header-anchor">#</a> Default values</h3> <p>Default values for the data properties can be defined with the <code>:default</code> option. Its value is used as the default value of the Elixir struct.
If not specified otherwise, the default value will be <code>nil</code>, just like the default value on any Elixir struct, for single value properties. But for properties with multiple values it will be the empty list by default.</p> <p>Generally, if a <code>:type</code> is defined, the <code>:default</code> value must match this datatype. Otherwise it won't compile.</p> <h2 id="link-properties"><a href="#link-properties" aria-hidden="true" class="header-anchor">#</a> Link properties</h2> <p>Now, back to our two kinds of properties, we'll see how link properties are mapped to other Grax schemas.</p> <p>Link properties, in the following sometimes called more shortly links, are the edges of an RDF graph between the inner nodes with URIs or blank nodes, as opposed to data properties which are the edges to leaf nodes with RDF literals. Other than for data properties, the actual value of a link property with a node identifier like an URI or a blank node is not of interest, but it's the description of the thing the identifier refers to. So, the values of link properties are not the URIs or blank nodes in the object position of an RDF statement, but another Grax schema with the properties from the RDF description of the linked resource.</p> <p>Just like relational associations are in Ecto mapped to the struct fields through another Ecto schema for the associated table, the linked resources of a root resource are embedded into the struct in the respective field, where the properties of the linked resource are kept, potentially linking to other resources. So, the links allow us to traverse the nodes of a graph, as a tree structure down from a root resource and its fields of nested <code>Grax.Schema</code> structs.</p> <p>A Grax link can be defined in a Grax <code>schema</code> definition with another macro specifically for link properties: the <code>link/3</code> macro.
It has almost the same interface as the <code>property/3</code> macro. The first two arguments are again for the name and IRI of the property.
The <code>:type</code> option however has a different meaning and is no longer optional. It must be the module name of another <code>Grax.Schema</code> struct.</p> <div class="language-elixir extra-class"><div class="highlight-lines"><br><br><br><br><br><br><br><br><br><br><div class="highlighted">Â </div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br></div><pre class="language-elixir"><code><span class="token keyword">defmodule</span> User <span class="token keyword">do</span>
  <span class="token keyword">use</span> Grax<span class="token punctuation">.</span>Schema

  <span class="token keyword">alias</span> NS<span class="token punctuation">.</span>SchemaOrg

  schema <span class="token keyword">do</span>
    property <span class="token atom symbol">:name</span><span class="token punctuation">,</span> SchemaOrg<span class="token punctuation">.</span>name<span class="token punctuation">,</span> <span class="token attr-name">type:</span> <span class="token atom symbol">:string</span><span class="token punctuation">,</span> <span class="token attr-name">required:</span> <span class="token boolean">true</span>
    property <span class="token atom symbol">:emails</span><span class="token punctuation">,</span> SchemaOrg<span class="token punctuation">.</span>email<span class="token punctuation">,</span> <span class="token attr-name">type:</span> list_of<span class="token punctuation">(</span><span class="token atom symbol">:string</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token attr-name">required:</span> <span class="token boolean">true</span>
    property <span class="token atom symbol">:age</span><span class="token punctuation">,</span> FOAF<span class="token punctuation">.</span>age<span class="token punctuation">,</span> <span class="token attr-name">type:</span> <span class="token atom symbol">:integer</span>

    link <span class="token atom symbol">:address</span><span class="token punctuation">,</span> SchemaOrg<span class="token punctuation">.</span>address<span class="token punctuation">,</span> <span class="token attr-name">type:</span> Address
  <span class="token keyword">end</span>
<span class="token keyword">end</span>

<span class="token keyword">defmodule</span> Address <span class="token keyword">do</span>
  <span class="token keyword">use</span> Grax<span class="token punctuation">.</span>Schema

  <span class="token keyword">alias</span> NS<span class="token punctuation">.</span>SchemaOrg

  schema <span class="token keyword">do</span>
    property <span class="token atom symbol">:country</span><span class="token punctuation">,</span> SchemaOrg<span class="token punctuation">.</span>addressCountry<span class="token punctuation">,</span> <span class="token attr-name">type:</span> <span class="token atom symbol">:string</span>
    property <span class="token atom symbol">:city</span><span class="token punctuation">,</span> SchemaOrg<span class="token punctuation">.</span>addressLocality<span class="token punctuation">,</span> <span class="token attr-name">type:</span> <span class="token atom symbol">:string</span>
    property <span class="token atom symbol">:street</span><span class="token punctuation">,</span> SchemaOrg<span class="token punctuation">.</span>streetAddress<span class="token punctuation">,</span> <span class="token attr-name">type:</span> <span class="token atom symbol">:string</span>
  <span class="token keyword">end</span>
<span class="token keyword">end</span>
</code></pre></div><p>Just like the <code>property</code> macro, there is also a <code>link/1</code> variant, allowing to define the link more succinctly.</p> <div class="language-elixir extra-class"><pre class="language-elixir"><code><span class="token keyword">defmodule</span> User <span class="token keyword">do</span>
  <span class="token keyword">use</span> Grax<span class="token punctuation">.</span>Schema

  <span class="token keyword">alias</span> NS<span class="token punctuation">.</span>SchemaOrg

  schema <span class="token keyword">do</span>
    link <span class="token attr-name">address:</span> SchemaOrg<span class="token punctuation">.</span>address<span class="token punctuation">,</span> <span class="token attr-name">type:</span> Address
  <span class="token keyword">end</span>
<span class="token keyword">end</span>
</code></pre></div><p>So, our <code>User</code> struct now looks like this:</p> <div class="language-elixir extra-class"><pre class="language-elixir"><code><span class="token punctuation">%</span>User<span class="token punctuation">{</span>
  <span class="token attr-name">__id__:</span> RDF<span class="token punctuation">.</span>iri<span class="token punctuation">(</span>EX<span class="token punctuation">.</span>User1<span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token attr-name">name:</span> <span class="token string">&quot;Jane&quot;</span><span class="token punctuation">,</span>
  <span class="token attr-name">emails:</span> <span class="token punctuation">[</span><span class="token string">&quot;jane@example.com&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;jane@work.com&quot;</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token attr-name">age:</span> <span class="token number">30</span><span class="token punctuation">,</span>
  <span class="token attr-name">address:</span> <span class="token punctuation">%</span>Address<span class="token punctuation">{</span>
    <span class="token attr-name">__id__:</span> RDF<span class="token punctuation">.</span>blank_node<span class="token punctuation">(</span><span class="token string">&quot;b1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token attr-name">country:</span> <span class="token string">&quot;de&quot;</span><span class="token punctuation">,</span>
    <span class="token attr-name">city:</span> <span class="token string">&quot;Berlin&quot;</span><span class="token punctuation">,</span>
    <span class="token attr-name">street:</span> <span class="token boolean">nil</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>While you have to deal in Ecto with the relational data model with different types of associations and mappings in the relational data model (1-to-1, 1-to-n, n-to-m, with an implicit or explicit join-schema etc.), the graph data model just has edges with different kinds of cardinalities, which are in Grax mapped to either single values or a list of multiple values, just like data properties, only that it's now just single or multiple schema structs for the linked nodes.
Just as for data properties single linked schema structs are assumed unless it is list type is set on the  <code>:type</code> keyword with the <code>list_of</code> function and the module name of the schema.</p> <div class="language-elixir extra-class"><pre class="language-elixir"><code><span class="token keyword">defmodule</span> User <span class="token keyword">do</span>
  <span class="token keyword">use</span> Grax<span class="token punctuation">.</span>Schema

  <span class="token keyword">alias</span> NS<span class="token punctuation">.</span><span class="token punctuation">{</span>SchemaOrg<span class="token punctuation">,</span> FOAF<span class="token punctuation">}</span>

  schema <span class="token keyword">do</span>
    property <span class="token atom symbol">:name</span><span class="token punctuation">,</span> SchemaOrg<span class="token punctuation">.</span>name<span class="token punctuation">,</span> <span class="token attr-name">type:</span> <span class="token atom symbol">:string</span><span class="token punctuation">,</span> <span class="token attr-name">required:</span> <span class="token boolean">true</span>
    property <span class="token atom symbol">:emails</span><span class="token punctuation">,</span> SchemaOrg<span class="token punctuation">.</span>email<span class="token punctuation">,</span> <span class="token attr-name">type:</span> list_of<span class="token punctuation">(</span><span class="token atom symbol">:string</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token attr-name">required:</span> <span class="token boolean">true</span>
    property <span class="token atom symbol">:age</span><span class="token punctuation">,</span> FOAF<span class="token punctuation">.</span>age<span class="token punctuation">,</span> <span class="token attr-name">type:</span> <span class="token atom symbol">:integer</span>
    
    link <span class="token attr-name">address:</span> SchemaOrg<span class="token punctuation">.</span>address<span class="token punctuation">,</span> <span class="token attr-name">type:</span> Address
    link <span class="token attr-name">friends:</span> FOAF<span class="token punctuation">.</span>friend<span class="token punctuation">,</span> <span class="token attr-name">type:</span> list_of<span class="token punctuation">(</span>User<span class="token punctuation">)</span>
  <span class="token keyword">end</span>
<span class="token keyword">end</span>
</code></pre></div><p>But as you might see already with this link property, there's one problem we'll have to solve.</p> <h3 id="preloading"><a href="#preloading" aria-hidden="true" class="header-anchor">#</a> Preloading</h3> <p>Preloading is the operation of populating a <code>Grax.Schema</code> struct by loading (mapping) the RDF descriptions of linked resources from an RDF graph into a tree structure over the linked property fields of a <code>Grax.Schema</code> recursively.</p> <p>You might have already asked yourself, how the recursive traversal of the graph for loading the nested schema of a root node is done and can be controlled.
For example on our <code>friends</code> link: How many levels of friends do we want to load and how do we handle circles?</p> <p>There are potentially several useful preloading strategies, which should be implemented in possible future versions. For now, the only preloading strategy supported is a pretty simple one, the <em>depth preloading</em> strategy, where all of the properties and links up to a specified recursive depth are loaded.</p> <p>The default behaviour for how deep the links of a mapping struct are loaded can be specified on a <code>link</code> definition with the <code>:depth</code> keyword of the depth preloading strategy and an integer for the preloading depth.
But before we look at a use of the <code>:depth</code> keyword, let's see what happens if our address model would get further nested by decomposing one of its parts, eg. the country.</p> <div class="language-elixir extra-class"><pre class="language-elixir"><code><span class="token keyword">defmodule</span> User <span class="token keyword">do</span>
  <span class="token keyword">use</span> Grax<span class="token punctuation">.</span>Schema

  <span class="token keyword">alias</span> NS<span class="token punctuation">.</span>SchemaOrg

  schema <span class="token keyword">do</span>
    property <span class="token attr-name">name:</span> SchemaOrg<span class="token punctuation">.</span>name<span class="token punctuation">,</span> <span class="token attr-name">type:</span> <span class="token atom symbol">:string</span><span class="token punctuation">,</span> <span class="token attr-name">required:</span> <span class="token boolean">true</span>
    property <span class="token attr-name">emails:</span> SchemaOrg<span class="token punctuation">.</span>email<span class="token punctuation">,</span> <span class="token attr-name">type:</span> list_of<span class="token punctuation">(</span><span class="token atom symbol">:string</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token attr-name">required:</span> <span class="token boolean">true</span>
    property <span class="token attr-name">age:</span> FOAF<span class="token punctuation">.</span>age<span class="token punctuation">,</span> <span class="token attr-name">type:</span> <span class="token atom symbol">:integer</span>

    link <span class="token atom symbol">:address</span><span class="token punctuation">,</span> SchemaOrg<span class="token punctuation">.</span>address<span class="token punctuation">,</span> <span class="token attr-name">type:</span> Address
  <span class="token keyword">end</span>
<span class="token keyword">end</span>

<span class="token keyword">defmodule</span> Address <span class="token keyword">do</span>
  <span class="token keyword">use</span> Grax<span class="token punctuation">.</span>Schema

  <span class="token keyword">alias</span> NS<span class="token punctuation">.</span>SchemaOrg

  schema <span class="token keyword">do</span>
    property <span class="token attr-name">street:</span> SchemaOrg<span class="token punctuation">.</span>streetAddress<span class="token punctuation">,</span> <span class="token attr-name">type:</span> <span class="token atom symbol">:string</span>
    property <span class="token attr-name">city:</span> SchemaOrg<span class="token punctuation">.</span>addressLocality<span class="token punctuation">,</span> <span class="token attr-name">type:</span> <span class="token atom symbol">:string</span>

    link <span class="token attr-name">country:</span> SchemaOrg<span class="token punctuation">.</span>addressCountry<span class="token punctuation">,</span> <span class="token attr-name">type:</span> Country
  <span class="token keyword">end</span>
<span class="token keyword">end</span>

<span class="token keyword">defmodule</span> Country <span class="token keyword">do</span>
  <span class="token keyword">use</span> Grax<span class="token punctuation">.</span>Schema

  <span class="token keyword">alias</span> RDF<span class="token punctuation">.</span>NS<span class="token punctuation">.</span>RDFS
  <span class="token keyword">alias</span> NS<span class="token punctuation">.</span>GeoNames

  schema <span class="token keyword">do</span>
    property <span class="token attr-name">name:</span> RDFS<span class="token punctuation">.</span>label<span class="token punctuation">,</span> <span class="token attr-name">type:</span> <span class="token atom symbol">:string</span>
    property <span class="token attr-name">code:</span> GeoNames<span class="token punctuation">.</span>countryCode<span class="token punctuation">,</span> <span class="token attr-name">type:</span> <span class="token atom symbol">:string</span>
  <span class="token keyword">end</span>
<span class="token keyword">end</span>
</code></pre></div><p>The default value for <code>:depth</code> is <code>1</code>. This means all of the data and object properties are loaded, including the nested <code>Grax.Schema</code> mapping with the descriptions of a linked resource, BUT NOT the linked <code>Grax.Schema</code> structs of these nested <code>Grax.Schema</code> structs. These would only be preloaded if the depth was one more and so on. So, without a further specification of the preloading depth with the <code>:depth</code> keyword, our <code>User</code> struct would look like this.</p> <div class="language-elixir extra-class"><div class="highlight-lines"><br><br><br><br><br><br><br><br><br><div class="highlighted">Â </div><br><br><br></div><pre class="language-elixir"><code><span class="token punctuation">%</span>User<span class="token punctuation">{</span>
  <span class="token attr-name">__id__:</span> RDF<span class="token punctuation">.</span>iri<span class="token punctuation">(</span>EX<span class="token punctuation">.</span>User1<span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token attr-name">name:</span> <span class="token string">&quot;Jane&quot;</span><span class="token punctuation">,</span>
  <span class="token attr-name">emails:</span> <span class="token punctuation">[</span><span class="token string">&quot;jane@example.com&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;jane@work.com&quot;</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token attr-name">age:</span> <span class="token number">30</span><span class="token punctuation">,</span>
  <span class="token attr-name">address:</span> <span class="token punctuation">%</span>Address<span class="token punctuation">{</span>
    <span class="token attr-name">__id__:</span> ~B<span class="token string">&quot;b1&quot;</span><span class="token punctuation">,</span>
    <span class="token attr-name">city:</span> <span class="token string">&quot;Berlin&quot;</span><span class="token punctuation">,</span>
    <span class="token attr-name">street:</span> <span class="token boolean">nil</span><span class="token punctuation">,</span>
    <span class="token attr-name">country:</span> ~I<span class="token operator">&lt;</span><span class="token attr-name">http:</span><span class="token operator">/</span><span class="token operator">/</span>www<span class="token punctuation">.</span>wikidata<span class="token punctuation">.</span>org<span class="token operator">/</span>entity<span class="token operator">/</span>Q183<span class="token operator">&gt;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>When loading a <code>Grax.Schema</code> struct the fields for the links which are not loaded just have their node identifier as a value.
If you've got a <code>Grax.Schema</code> struct with <code>RDF.IRI</code>s or <code>RDF.BlankNode</code>s like this on the link field and want to access the referenced recource, you'll have to do an explicit call of the <code>Grax.preload/3</code> function described in the next chapter about the API.</p> <p>But to ensure a proper processing of the Grax schema structs, which might expect certain fields in deeper layers of the struct, you don't want to check for these values and have to do a manual preload. In cases like this, you can enforce the depth of the preloading with the <code>:depth</code> keyword. This can be achieved in multiple ways.</p> <p>The first approach might be to increase the depth on the <code>address</code> link to 2.</p> <div class="language-elixir extra-class"><div class="highlight-lines"><br><br><br><br><br><br><br><br><br><br><div class="highlighted">Â </div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br></div><pre class="language-elixir"><code><span class="token keyword">defmodule</span> User <span class="token keyword">do</span>
  <span class="token keyword">use</span> Grax<span class="token punctuation">.</span>Schema

  <span class="token keyword">alias</span> NS<span class="token punctuation">.</span>SchemaOrg

  schema <span class="token keyword">do</span>
    property <span class="token attr-name">name:</span> SchemaOrg<span class="token punctuation">.</span>name<span class="token punctuation">,</span> <span class="token attr-name">type:</span> <span class="token atom symbol">:string</span><span class="token punctuation">,</span> <span class="token attr-name">required:</span> <span class="token boolean">true</span>
    property <span class="token attr-name">emails:</span> SchemaOrg<span class="token punctuation">.</span>email<span class="token punctuation">,</span> <span class="token attr-name">type:</span> list_of<span class="token punctuation">(</span><span class="token atom symbol">:string</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token attr-name">required:</span> <span class="token boolean">true</span>
    property <span class="token attr-name">age:</span> FOAF<span class="token punctuation">.</span>age<span class="token punctuation">,</span> <span class="token attr-name">type:</span> <span class="token atom symbol">:integer</span>

    link <span class="token atom symbol">:address</span><span class="token punctuation">,</span> SchemaOrg<span class="token punctuation">.</span>address<span class="token punctuation">,</span> <span class="token attr-name">type:</span> Address<span class="token punctuation">,</span> <span class="token attr-name">depth:</span> <span class="token number">2</span>
  <span class="token keyword">end</span>
<span class="token keyword">end</span>

<span class="token keyword">defmodule</span> Address <span class="token keyword">do</span>
  <span class="token keyword">use</span> Grax<span class="token punctuation">.</span>Schema

  <span class="token keyword">alias</span> NS<span class="token punctuation">.</span>SchemaOrg

  schema <span class="token keyword">do</span>
    property <span class="token attr-name">street:</span> SchemaOrg<span class="token punctuation">.</span>streetAddress<span class="token punctuation">,</span> <span class="token attr-name">type:</span> <span class="token atom symbol">:string</span>
    property <span class="token attr-name">city:</span> SchemaOrg<span class="token punctuation">.</span>addressLocality<span class="token punctuation">,</span> <span class="token attr-name">type:</span> <span class="token atom symbol">:string</span>

    link <span class="token attr-name">country:</span> SchemaOrg<span class="token punctuation">.</span>addressCountry<span class="token punctuation">,</span> <span class="token attr-name">type:</span> Country
  <span class="token keyword">end</span>
<span class="token keyword">end</span>
</code></pre></div><p>Given respective data in a source graph our <code>User</code> struct could now look like this:</p> <div class="language-elixir extra-class"><div class="highlight-lines"><br><br><br><br><br><br><br><br><br><div class="highlighted">Â </div><div class="highlighted">Â </div><div class="highlighted">Â </div><div class="highlighted">Â </div><div class="highlighted">Â </div><br><br><br></div><pre class="language-elixir"><code><span class="token punctuation">%</span>User<span class="token punctuation">{</span>
  <span class="token attr-name">__id__:</span> RDF<span class="token punctuation">.</span>iri<span class="token punctuation">(</span>EX<span class="token punctuation">.</span>User1<span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token attr-name">name:</span> <span class="token string">&quot;Jane&quot;</span><span class="token punctuation">,</span>
  <span class="token attr-name">emails:</span> <span class="token punctuation">[</span><span class="token string">&quot;jane@example.com&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;jane@work.com&quot;</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token attr-name">age:</span> <span class="token number">30</span><span class="token punctuation">,</span>
  <span class="token attr-name">address:</span> <span class="token punctuation">%</span>Address<span class="token punctuation">{</span>
    <span class="token attr-name">__id__:</span> ~B<span class="token string">&quot;b1&quot;</span><span class="token punctuation">,</span>
    <span class="token attr-name">city:</span> <span class="token string">&quot;Berlin&quot;</span><span class="token punctuation">,</span>
    <span class="token attr-name">street:</span> <span class="token boolean">nil</span><span class="token punctuation">,</span>
    <span class="token attr-name">country:</span> <span class="token punctuation">%</span>Country<span class="token punctuation">{</span>
      <span class="token attr-name">__id__:</span> ~I<span class="token operator">&lt;</span><span class="token attr-name">http:</span><span class="token operator">/</span><span class="token operator">/</span>www<span class="token punctuation">.</span>wikidata<span class="token punctuation">.</span>org<span class="token operator">/</span>entity<span class="token operator">/</span>Q183<span class="token operator">&gt;</span><span class="token punctuation">,</span>
      <span class="token attr-name">name:</span> <span class="token string">&quot;Germany&quot;</span><span class="token punctuation">,</span>
      <span class="token attr-name">code:</span> <span class="token string">&quot;DE&quot;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>But we would get this result only if the <code>User</code> struct is the root resource.
A normal preloading depth integer value is interpreted against the root element. This means, when loading the schema from a graph, only the specified <code>:depth</code> of the root resource is relevant. The <code>:depth</code> specified in the schema of a linked resource is not taken into account and doesn't increase the overall preloading depth. This can be achieved however, by specifying a preloading depth with a plus sign before the <code>:depth</code> integer value, like <code>depth: +1</code> . This <em>additive</em> preloading depth will ensure that these resources are preloaded with the specified level even when the <code>:depth</code> of the outer schema would specify otherwise.
So, this essentially overwrites the preloading depth specification of the parent schema.</p> <p>Back to our example, when we generally expect that code dealing with an address in our application is interested in the properties of the country, we want to achieve that the country is always preloaded with the address, independent of whether it is preloaded as part of another resource. This can be specified with an additive preloading depth.</p> <div class="language-elixir extra-class"><div class="highlight-lines"><br><br><br><br><br><br><br><br><br><br><div class="highlighted">Â </div><br><br><br><br><br><br><br><br><br><br><br><br><div class="highlighted">Â </div><br><br><br></div><pre class="language-elixir"><code><span class="token keyword">defmodule</span> User <span class="token keyword">do</span>
  <span class="token keyword">use</span> Grax<span class="token punctuation">.</span>Schema

  <span class="token keyword">alias</span> NS<span class="token punctuation">.</span>SchemaOrg

  schema <span class="token keyword">do</span>
    property <span class="token attr-name">name:</span> SchemaOrg<span class="token punctuation">.</span>name<span class="token punctuation">,</span> <span class="token attr-name">type:</span> <span class="token atom symbol">:string</span><span class="token punctuation">,</span> <span class="token attr-name">required:</span> <span class="token boolean">true</span>
    property <span class="token attr-name">emails:</span> SchemaOrg<span class="token punctuation">.</span>email<span class="token punctuation">,</span> <span class="token attr-name">type:</span> list_of<span class="token punctuation">(</span><span class="token atom symbol">:string</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token attr-name">required:</span> <span class="token boolean">true</span>
    property <span class="token attr-name">age:</span> FOAF<span class="token punctuation">.</span>age<span class="token punctuation">,</span> <span class="token attr-name">type:</span> <span class="token atom symbol">:integer</span>

    link <span class="token atom symbol">:address</span><span class="token punctuation">,</span> SchemaOrg<span class="token punctuation">.</span>address<span class="token punctuation">,</span> <span class="token attr-name">type:</span> Address
  <span class="token keyword">end</span>
<span class="token keyword">end</span>

<span class="token keyword">defmodule</span> Address <span class="token keyword">do</span>
  <span class="token keyword">use</span> Grax<span class="token punctuation">.</span>Schema

  <span class="token keyword">alias</span> NS<span class="token punctuation">.</span>SchemaOrg

  schema <span class="token keyword">do</span>
    property <span class="token attr-name">street:</span> SchemaOrg<span class="token punctuation">.</span>streetAddress<span class="token punctuation">,</span> <span class="token attr-name">type:</span> <span class="token atom symbol">:string</span>
    property <span class="token attr-name">city:</span> SchemaOrg<span class="token punctuation">.</span>addressLocality<span class="token punctuation">,</span> <span class="token attr-name">type:</span> <span class="token atom symbol">:string</span>

    link <span class="token attr-name">country:</span> SchemaOrg<span class="token punctuation">.</span>addressCountry<span class="token punctuation">,</span> <span class="token attr-name">type:</span> Country<span class="token punctuation">,</span> <span class="token attr-name">depth:</span> <span class="token operator">+</span><span class="token number">1</span>
  <span class="token keyword">end</span>
<span class="token keyword">end</span>
</code></pre></div><p>If all link properties of schema should have the same preloading depth, the <code>:depth</code> keyword can also be specified on the <code>use Graph.Schema</code> call.</p> <div class="language-elixir extra-class"><div class="highlight-lines"><br><br><br><br><br><br><br><br><br><br><div class="highlighted">Â </div><br><br><br><br><div class="highlighted">Â </div><br><br><br><br><br><br><br><div class="highlighted">Â </div><br><br><br></div><pre class="language-elixir"><code><span class="token keyword">defmodule</span> User <span class="token keyword">do</span>
  <span class="token keyword">use</span> Grax<span class="token punctuation">.</span>Schema

  <span class="token keyword">alias</span> NS<span class="token punctuation">.</span>SchemaOrg

  schema <span class="token keyword">do</span>
    property <span class="token attr-name">name:</span> SchemaOrg<span class="token punctuation">.</span>name<span class="token punctuation">,</span> <span class="token attr-name">type:</span> <span class="token atom symbol">:string</span><span class="token punctuation">,</span> <span class="token attr-name">required:</span> <span class="token boolean">true</span>
    property <span class="token attr-name">emails:</span> SchemaOrg<span class="token punctuation">.</span>email<span class="token punctuation">,</span> <span class="token attr-name">type:</span> list_of<span class="token punctuation">(</span><span class="token atom symbol">:string</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token attr-name">required:</span> <span class="token boolean">true</span>
    property <span class="token attr-name">age:</span> FOAF<span class="token punctuation">.</span>age<span class="token punctuation">,</span> <span class="token attr-name">type:</span> <span class="token atom symbol">:integer</span>

    link <span class="token atom symbol">:address</span><span class="token punctuation">,</span> SchemaOrg<span class="token punctuation">.</span>address<span class="token punctuation">,</span> <span class="token attr-name">type:</span> Address
  <span class="token keyword">end</span>
<span class="token keyword">end</span>

<span class="token keyword">defmodule</span> Address <span class="token keyword">do</span>
  <span class="token keyword">use</span> Grax<span class="token punctuation">.</span>Schema<span class="token punctuation">,</span> <span class="token attr-name">depth:</span> <span class="token operator">+</span><span class="token number">1</span>

  <span class="token keyword">alias</span> NS<span class="token punctuation">.</span>SchemaOrg

  schema <span class="token keyword">do</span>
    property <span class="token attr-name">street:</span> SchemaOrg<span class="token punctuation">.</span>streetAddress<span class="token punctuation">,</span> <span class="token attr-name">type:</span> <span class="token atom symbol">:string</span>
    property <span class="token attr-name">city:</span> SchemaOrg<span class="token punctuation">.</span>addressLocality<span class="token punctuation">,</span> <span class="token attr-name">type:</span> <span class="token atom symbol">:string</span>

    link <span class="token attr-name">country:</span> SchemaOrg<span class="token punctuation">.</span>addressCountry<span class="token punctuation">,</span> <span class="token attr-name">type:</span> Country
  <span class="token keyword">end</span>
<span class="token keyword">end</span>
</code></pre></div><p>But additive preloading depths can lead to infinite preloading circles. This is prohibited by stopping with the preloading down a path, when the first already preloaded element on this path reoccurs.</p> <p>This a pretty greedy preloading strategy. But in the first version, which is limited to working on in-memory RDF.ex graphs, where loading is quite fast and the data access doesn't require any further IO, this simple strategy gets us already quite far.</p> <h3 id="inverse-property-links"><a href="#inverse-property-links" aria-hidden="true" class="header-anchor">#</a> Inverse property links</h3> <p>Sometimes we want to define a <code>link</code> on a <code>Grax.Schema</code> for which no RDF property exists directly. For example, in our data there is no property linking a user to a post directly. Instead there is the <code>schema:author</code>property which links a post to its authors, so exactly the inverse property of what we want. You can specify a link property on a <code>Grax.Schema</code> in those cases by declaring it as an inverse property with a minus sign before the IRI of the inverse property.</p> <div class="language-elixir extra-class"><div class="highlight-lines"><br><br><br><br><br><br><br><br><br><br><br><div class="highlighted">Â </div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br></div><pre class="language-elixir"><code><span class="token keyword">defmodule</span> User <span class="token keyword">do</span>
  <span class="token keyword">use</span> Grax<span class="token punctuation">.</span>Schema

  <span class="token keyword">alias</span> NS<span class="token punctuation">.</span><span class="token punctuation">{</span>SchemaOrg<span class="token punctuation">,</span> FOAF<span class="token punctuation">}</span>

  schema <span class="token keyword">do</span>
    property <span class="token attr-name">name:</span> SchemaOrg<span class="token punctuation">.</span>name<span class="token punctuation">,</span> <span class="token attr-name">type:</span> <span class="token atom symbol">:string</span><span class="token punctuation">,</span> <span class="token attr-name">required:</span> <span class="token boolean">true</span>
    property <span class="token attr-name">emails:</span> SchemaOrg<span class="token punctuation">.</span>email<span class="token punctuation">,</span> <span class="token attr-name">type:</span> list_of<span class="token punctuation">(</span><span class="token atom symbol">:string</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token attr-name">required:</span> <span class="token boolean">true</span>
    property <span class="token attr-name">age:</span> FOAF<span class="token punctuation">.</span>age<span class="token punctuation">,</span> <span class="token attr-name">type:</span> <span class="token atom symbol">:integer</span>
    
    link <span class="token attr-name">friends:</span> FOAF<span class="token punctuation">.</span>friend<span class="token punctuation">,</span> <span class="token attr-name">type:</span> list_of<span class="token punctuation">(</span>User<span class="token punctuation">)</span>
    link <span class="token attr-name">posts:</span> <span class="token operator">-</span>SchemaOrg<span class="token punctuation">.</span>author<span class="token punctuation">,</span> <span class="token attr-name">type:</span> list_of<span class="token punctuation">(</span>Post<span class="token punctuation">)</span>
  <span class="token keyword">end</span>
<span class="token keyword">end</span>

<span class="token keyword">defmodule</span> Post <span class="token keyword">do</span>
  <span class="token keyword">use</span> Grax<span class="token punctuation">.</span>Schema

  <span class="token keyword">alias</span> NS<span class="token punctuation">.</span>SchemaOrg

  schema <span class="token keyword">do</span>
    property <span class="token attr-name">title:</span> SchemaOrg<span class="token punctuation">.</span>name<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token attr-name">type:</span> <span class="token atom symbol">:string</span>
    property <span class="token attr-name">content:</span> SchemaOrg<span class="token punctuation">.</span>articleBody<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token attr-name">type:</span> <span class="token atom symbol">:string</span>

    link <span class="token attr-name">author:</span> SchemaOrg<span class="token punctuation">.</span>author<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token attr-name">type:</span> User
  <span class="token keyword">end</span>
<span class="token keyword">end</span>
</code></pre></div><h3 id="heterogeneous-property-links"><a href="#heterogeneous-property-links" aria-hidden="true" class="header-anchor">#</a> Heterogeneous property links</h3> <p>Links can also link different types of resources to different schemas. For this, the <code>:type</code> of a link property must be given as a map of class URIs to Grax schemas.</p> <div class="language-elixir extra-class"><pre class="language-elixir"><code><span class="token keyword">defmodule</span> User <span class="token keyword">do</span>
  <span class="token keyword">use</span> Grax<span class="token punctuation">.</span>Schema

  <span class="token keyword">alias</span> NS<span class="token punctuation">.</span><span class="token punctuation">{</span>SchemaOrg<span class="token punctuation">,</span> FOAF<span class="token punctuation">}</span>

  schema <span class="token keyword">do</span>
    property <span class="token attr-name">name:</span> SchemaOrg<span class="token punctuation">.</span>name<span class="token punctuation">,</span> <span class="token attr-name">type:</span> <span class="token atom symbol">:string</span><span class="token punctuation">,</span> <span class="token attr-name">required:</span> <span class="token boolean">true</span>
    property <span class="token attr-name">emails:</span> SchemaOrg<span class="token punctuation">.</span>email<span class="token punctuation">,</span> <span class="token attr-name">type:</span> list_of<span class="token punctuation">(</span><span class="token atom symbol">:string</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token attr-name">required:</span> <span class="token boolean">true</span>
    property <span class="token attr-name">age:</span> FOAF<span class="token punctuation">.</span>age<span class="token punctuation">,</span> <span class="token attr-name">type:</span> <span class="token atom symbol">:integer</span>
    
    link <span class="token attr-name">friends:</span> FOAF<span class="token punctuation">.</span>friend<span class="token punctuation">,</span> <span class="token attr-name">type:</span> list_of<span class="token punctuation">(</span>User<span class="token punctuation">)</span>
    link <span class="token attr-name">posts:</span> <span class="token operator">-</span>SchemaOrg<span class="token punctuation">.</span>author<span class="token punctuation">,</span> <span class="token attr-name">type:</span> list_of<span class="token punctuation">(</span><span class="token punctuation">%</span><span class="token punctuation">{</span>
        SchemaOrg<span class="token punctuation">.</span>BlogPosting <span class="token operator">=&gt;</span> Post<span class="token punctuation">,</span>
        SchemaOrg<span class="token punctuation">.</span>Comment <span class="token operator">=&gt;</span> Comment
      <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token keyword">end</span>
<span class="token keyword">end</span>

<span class="token keyword">defmodule</span> Comment <span class="token keyword">do</span>
  <span class="token keyword">use</span> Grax<span class="token punctuation">.</span>Schema

  <span class="token keyword">alias</span> NS<span class="token punctuation">.</span>SchemaOrg

  schema <span class="token keyword">do</span>
    property <span class="token attr-name">content:</span> SchemaOrg<span class="token punctuation">.</span>text<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token attr-name">type:</span> <span class="token atom symbol">:string</span>

    link <span class="token attr-name">author:</span> SchemaOrg<span class="token punctuation">.</span>author<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token attr-name">type:</span> User
  <span class="token keyword">end</span>
<span class="token keyword">end</span>
</code></pre></div><p>So, depending on the <code>rdf:type</code> of the resource linked with a property the specified schema is used. When a linked resource doesn't have any of the specified types, the resource is ignored by default. You can change this behaviour and get an error in this case, by setting the <code>:on_type_mismatch</code> option to <code>:error</code>. Another way to deal with this situation is to provide a fallback in the type-schema mapping where  <code>nil</code> is used as the key instead of a class URI. The schema associated with <code>nil</code> will then be used when none of the other class URI matches an <code>rdf:type</code>. When multiple classes of a linked resource are matching, you'll always get an error.</p> <h2 id="cardinalities"><a href="#cardinalities" aria-hidden="true" class="header-anchor">#</a> Cardinalities</h2> <p>You can define the cardinality the values of data properties and links of a schema must have in order to be considered valid. For non-list properties there are just two possible cardinalities: 1 or 0..1 or, in other words, required or not, which can be specified with the <code>:required</code> option defaulting to <code>false</code>.</p> <div class="language-elixir extra-class"><pre class="language-elixir"><code><span class="token keyword">defmodule</span> User <span class="token keyword">do</span>
  <span class="token keyword">use</span> Grax<span class="token punctuation">.</span>Schema

  <span class="token keyword">alias</span> NS<span class="token punctuation">.</span><span class="token punctuation">{</span>SchemaOrg<span class="token punctuation">,</span> FOAF<span class="token punctuation">}</span>

  schema <span class="token keyword">do</span>
    property <span class="token attr-name">name:</span> SchemaOrg<span class="token punctuation">.</span>name<span class="token punctuation">,</span> <span class="token attr-name">type:</span> <span class="token atom symbol">:string</span><span class="token punctuation">,</span> <span class="token attr-name">required:</span> <span class="token boolean">true</span>
    property <span class="token attr-name">emails:</span> SchemaOrg<span class="token punctuation">.</span>email<span class="token punctuation">,</span> <span class="token attr-name">type:</span> list_of<span class="token punctuation">(</span><span class="token atom symbol">:string</span><span class="token punctuation">)</span>
    property <span class="token attr-name">age:</span> FOAF<span class="token punctuation">.</span>age<span class="token punctuation">,</span> <span class="token attr-name">type:</span> <span class="token atom symbol">:integer</span>
  <span class="token keyword">end</span>
<span class="token keyword">end</span>
</code></pre></div><p>For list properties you can specify the cardinality on the <code>list</code> resp. <code>list_of</code> type constructor functions with the <code>:card</code> option. It can have</p> <ul><li>a single integer value for an exact cardinality,</li> <li>an Elixir range value (like <code>1..3</code>) for a cardinality with an lower and upper boundary,</li> <li>or a <code>{:min, n}</code> tuple value with an integer for a minimal cardinality without an upper boundary</li></ul> <div class="language-elixir extra-class"><pre class="language-elixir"><code><span class="token keyword">defmodule</span> User <span class="token keyword">do</span>
  <span class="token keyword">use</span> Grax<span class="token punctuation">.</span>Schema

  <span class="token keyword">alias</span> NS<span class="token punctuation">.</span><span class="token punctuation">{</span>SchemaOrg<span class="token punctuation">,</span> FOAF<span class="token punctuation">}</span>

  schema <span class="token keyword">do</span>
    property <span class="token attr-name">name:</span> SchemaOrg<span class="token punctuation">.</span>name<span class="token punctuation">,</span> <span class="token attr-name">type:</span> <span class="token atom symbol">:string</span><span class="token punctuation">,</span> <span class="token attr-name">required:</span> <span class="token boolean">true</span>
    property <span class="token attr-name">emails:</span> SchemaOrg<span class="token punctuation">.</span>email<span class="token punctuation">,</span> <span class="token attr-name">type:</span> list_of<span class="token punctuation">(</span><span class="token atom symbol">:string</span><span class="token punctuation">,</span> <span class="token attr-name">card:</span> <span class="token punctuation">{</span><span class="token atom symbol">:min</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
    property <span class="token attr-name">age:</span> FOAF<span class="token punctuation">.</span>age<span class="token punctuation">,</span> <span class="token attr-name">type:</span> <span class="token atom symbol">:integer</span>
  <span class="token keyword">end</span>
<span class="token keyword">end</span>
</code></pre></div><p>The <code>{:min, 1}</code> cardinality can be specified also by using the <code>:required</code> option on a list type. So, this is equivalent to the former definition:</p> <div class="language-elixir extra-class"><pre class="language-elixir"><code><span class="token keyword">defmodule</span> User <span class="token keyword">do</span>
  <span class="token keyword">use</span> Grax<span class="token punctuation">.</span>Schema

  <span class="token keyword">alias</span> NS<span class="token punctuation">.</span><span class="token punctuation">{</span>SchemaOrg<span class="token punctuation">,</span> FOAF<span class="token punctuation">}</span>

  schema <span class="token keyword">do</span>
    property <span class="token attr-name">name:</span> SchemaOrg<span class="token punctuation">.</span>name<span class="token punctuation">,</span> <span class="token attr-name">type:</span> <span class="token atom symbol">:string</span><span class="token punctuation">,</span> <span class="token attr-name">required:</span> <span class="token boolean">true</span>
    property <span class="token attr-name">emails:</span> SchemaOrg<span class="token punctuation">.</span>email<span class="token punctuation">,</span> <span class="token attr-name">type:</span> list_of<span class="token punctuation">(</span><span class="token atom symbol">:string</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token attr-name">required:</span> <span class="token boolean">true</span>
    property <span class="token attr-name">age:</span> FOAF<span class="token punctuation">.</span>age<span class="token punctuation">,</span> <span class="token attr-name">type:</span> <span class="token atom symbol">:integer</span>
  <span class="token keyword">end</span>
<span class="token keyword">end</span>
</code></pre></div><h2 id="class-declarations"><a href="#class-declarations" aria-hidden="true" class="header-anchor">#</a> Class declarations</h2> <p>You can optionally specify that the individual <code>Grax.Schema</code> structs representing RDF resources should be instances of an RDFS class by providing its IRI as an argument of the <code>schema</code> macro.</p> <div class="language-elixir extra-class"><div class="highlight-lines"><br><br><br><div class="highlighted">Â </div><br><br><br><br><br><br><br><div class="highlighted">Â </div><br><br><br><br><br><br><br><div class="highlighted">Â </div><br><br><br><br></div><pre class="language-elixir"><code><span class="token keyword">defmodule</span> User <span class="token keyword">do</span>
  <span class="token keyword">use</span> Grax<span class="token punctuation">.</span>Schema

  schema NS<span class="token punctuation">.</span>SchemaOrg<span class="token punctuation">.</span>Person <span class="token keyword">do</span>
    <span class="token comment"># ...  </span>
  <span class="token keyword">end</span>
<span class="token keyword">end</span>

<span class="token keyword">defmodule</span> Post <span class="token keyword">do</span>
  <span class="token keyword">use</span> Grax<span class="token punctuation">.</span>Schema

  schema NS<span class="token punctuation">.</span>SchemaOrg<span class="token punctuation">.</span>BlogPosting <span class="token keyword">do</span>
    <span class="token comment"># ...  </span>
  <span class="token keyword">end</span>
<span class="token keyword">end</span>

<span class="token keyword">defmodule</span> Address <span class="token keyword">do</span>
  <span class="token keyword">use</span> Grax<span class="token punctuation">.</span>Schema

  schema NS<span class="token punctuation">.</span>SchemaOrg<span class="token punctuation">.</span>PostalAddress <span class="token keyword">do</span>
    <span class="token comment"># ...  </span>
  <span class="token keyword">end</span>
<span class="token keyword">end</span>
</code></pre></div><p>For now, the only effect of a class declaration is that the mapping to RDF graphs will produce a <code>rdf:type</code> statement accordingly. In particular it doesn't mean that the RDF description of a resource must include a respective <code>rdf:type</code> to be loadable into a <code>Grax.Schema</code> struct.</p> <h2 id="schema-inheritance"><a href="#schema-inheritance" aria-hidden="true" class="header-anchor">#</a> Schema inheritance</h2> <p>It is possible to derive a schema from an existing one, inheriting all of its defined properties.</p> <div class="language-elixir extra-class"><pre class="language-elixir"><code><span class="token keyword">defmodule</span> Customer <span class="token keyword">do</span>
  <span class="token keyword">use</span> Grax<span class="token punctuation">.</span>Schema

  <span class="token keyword">alias</span> NS<span class="token punctuation">.</span>EX

  schema <span class="token attr-name">inherit:</span> User <span class="token keyword">do</span>
    property <span class="token attr-name">since:</span> EX<span class="token punctuation">.</span>customerSince<span class="token punctuation">,</span> <span class="token attr-name">type:</span> <span class="token atom symbol">:date</span>
    
    link <span class="token attr-name">subscription:</span> EX<span class="token punctuation">.</span>subscribed<span class="token punctuation">,</span> <span class="token attr-name">type:</span> Subscription
  <span class="token keyword">end</span>
<span class="token keyword">end</span>
</code></pre></div><p>If a class is also declared the following form is possible:</p> <div class="language-elixir extra-class"><pre class="language-elixir"><code><span class="token keyword">defmodule</span> Customer <span class="token keyword">do</span>
  <span class="token keyword">use</span> Grax<span class="token punctuation">.</span>Schema

  <span class="token keyword">alias</span> NS<span class="token punctuation">.</span>EX

  schema EX<span class="token punctuation">.</span>Customer <span class="token operator">&lt;</span> User <span class="token keyword">do</span>
    property <span class="token attr-name">since:</span> EX<span class="token punctuation">.</span>customerSince<span class="token punctuation">,</span> <span class="token attr-name">type:</span> <span class="token atom symbol">:date</span>
    
    link <span class="token attr-name">subscription:</span> EX<span class="token punctuation">.</span>subscribed<span class="token punctuation">,</span> <span class="token attr-name">type:</span> Subscription
  <span class="token keyword">end</span>
<span class="token keyword">end</span>
</code></pre></div><p>Multiple inheritance is also supported by providing the schemas in a list.</p> <p>Note, that the class must not necessarily be a subclass of the class of the inherited schema, although this might be the case often times.</p> <p>If some of the inherited properties should be redefined with other characteristics, this can be done without any restrictions. They can have a different type or map to a completely different RDF property, although this might be confusing.</p> <h2 id="custom-fields"><a href="#custom-fields" aria-hidden="true" class="header-anchor">#</a> Custom fields</h2> <p>If you already have or want to define certain fields on a <code>Grax.Schema</code> struct, which should be ignored by the RDF mapping, you can define them with the <code>field/1</code> macro.</p> <div class="language-elixir extra-class"><pre class="language-elixir"><code><span class="token keyword">defmodule</span> User <span class="token keyword">do</span>
  <span class="token keyword">use</span> Grax<span class="token punctuation">.</span>Schema

  <span class="token keyword">alias</span> NS<span class="token punctuation">.</span><span class="token punctuation">{</span>SchemaOrg<span class="token punctuation">,</span> FOAF<span class="token punctuation">}</span>

  schema <span class="token keyword">do</span>
    property <span class="token attr-name">name:</span> SchemaOrg<span class="token punctuation">.</span>name<span class="token punctuation">,</span> <span class="token attr-name">type:</span> <span class="token atom symbol">:string</span><span class="token punctuation">,</span> <span class="token attr-name">required:</span> <span class="token boolean">true</span>
    property <span class="token attr-name">emails:</span> SchemaOrg<span class="token punctuation">.</span>email<span class="token punctuation">,</span> <span class="token attr-name">type:</span> list_of<span class="token punctuation">(</span><span class="token atom symbol">:string</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token attr-name">required:</span> <span class="token boolean">true</span>
    property <span class="token attr-name">age:</span> FOAF<span class="token punctuation">.</span>age<span class="token punctuation">,</span> <span class="token attr-name">type:</span> <span class="token atom symbol">:integer</span>
    
    field <span class="token atom symbol">:password</span>
  <span class="token keyword">end</span>
<span class="token keyword">end</span>
</code></pre></div><p>The default value of a custom field can be specified optionally with the <code>:default</code> keyword.</p> <h2 id="custom-mappings"><a href="#custom-mappings" aria-hidden="true" class="header-anchor">#</a> Custom mappings</h2> <p>Sometimes you want to perform more complex or simply non-default transformations when mapping RDF data to and from the Elixir structs of your application. In these cases you can define your own custom mapping functions on the <code>Grax.Schema</code> module and declare their usage on the <code>property</code> schema definition with the <code>:from_rdf</code> and <code>:to_rdf</code> options and the respective function names.</p> <p>A <code>from_rdf</code> function must accept three arguments:</p> <ol><li>The first argument is the list of the actual RDF values for the property for which the custom mapping was called.</li> <li>The second argument is the <code>RDF.Description</code> of the mapped resource, which can be used when the mapping depends on other properties of the resource description.</li> <li>The third argument is whole <code>RDF.Graph</code> from which the mapping is called, which can be used when the mapping depends on other statements of the graph.</li></ol> <p>When a mapping can be performed successfully the mapped value must be returned in an <code>:ok</code> tuple. Otherwise an <code>:error</code> tuple with the error must be returned.</p> <p>A <code>to_rdf</code> function must accept two arguments:</p> <ol><li>The first argument is the list of the actual values of the property from the struct for which the custom mapping was called.</li> <li>The second argument is the whole <code>Grax</code> struct, which can be used when the mapping depends on other properties of it.</li></ol> <p>The return value can be either:</p> <ul><li>a two-element <code>:ok</code> tuple with the mapped RDF values</li> <li>a three-element <code>:ok</code> tuple with the mapped RDF values on second position and a list of additional RDF statements which should be added to the produced graph on the third position (the statements can be given in any form accepted by <code>RDF.Graph.add/2</code>)</li> <li>an <code>:error</code> tuple with an error</li></ul> <p>For both custom mapping functions you can return <code>nil</code> as a value when no values should be produced by the mapping.</p> <div class="language-elixir extra-class"><pre class="language-elixir"><code><span class="token keyword">defmodule</span> User <span class="token keyword">do</span>
  <span class="token keyword">use</span> Grax<span class="token punctuation">.</span>Schema

  <span class="token keyword">alias</span> NS<span class="token punctuation">.</span><span class="token punctuation">{</span>SchemaOrg<span class="token punctuation">,</span> FOAF<span class="token punctuation">,</span> EX<span class="token punctuation">}</span>

  schema SchemaOrg<span class="token punctuation">.</span>Person <span class="token keyword">do</span>
    property <span class="token attr-name">name:</span> SchemaOrg<span class="token punctuation">.</span>name<span class="token punctuation">,</span> <span class="token attr-name">type:</span> <span class="token atom symbol">:string</span><span class="token punctuation">,</span> <span class="token attr-name">required:</span> <span class="token boolean">true</span>
    property <span class="token attr-name">emails:</span> SchemaOrg<span class="token punctuation">.</span>email<span class="token punctuation">,</span> <span class="token attr-name">type:</span> list_of<span class="token punctuation">(</span><span class="token atom symbol">:string</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token attr-name">required:</span> <span class="token boolean">true</span>
    property <span class="token attr-name">age:</span> FOAF<span class="token punctuation">.</span>age<span class="token punctuation">,</span> <span class="token attr-name">type:</span> <span class="token atom symbol">:integer</span>

    property <span class="token attr-name">customer_type:</span> RDF<span class="token punctuation">.</span>type<span class="token punctuation">,</span> 
             <span class="token attr-name">from_rdf:</span> <span class="token atom symbol">:customer_type_from_rdf</span><span class="token punctuation">,</span>
             <span class="token attr-name">to_rdf:</span> <span class="token atom symbol">:customer_type_to_rdf</span>
    
    field <span class="token atom symbol">:password</span>

    link <span class="token attr-name">friends:</span> FOAF<span class="token punctuation">.</span>friend<span class="token punctuation">,</span> <span class="token attr-name">type:</span> list_of<span class="token punctuation">(</span>User<span class="token punctuation">)</span>
    link <span class="token attr-name">posts:</span> <span class="token operator">-</span>SchemaOrg<span class="token punctuation">.</span>author<span class="token punctuation">,</span> <span class="token attr-name">type:</span> list_of<span class="token punctuation">(</span>Post<span class="token punctuation">)</span>
  <span class="token keyword">end</span>

  <span class="token keyword">def</span> customer_type_from_rdf<span class="token punctuation">(</span>types<span class="token punctuation">,</span> _description<span class="token punctuation">,</span> _graph<span class="token punctuation">)</span> <span class="token keyword">do</span>
    <span class="token punctuation">{</span><span class="token atom symbol">:ok</span><span class="token punctuation">,</span> <span class="token keyword">if</span><span class="token punctuation">(</span>RDF<span class="token punctuation">.</span>iri<span class="token punctuation">(</span>EX<span class="token punctuation">.</span>PremiumUser<span class="token punctuation">)</span> <span class="token operator">in</span> types<span class="token punctuation">,</span> <span class="token attr-name">do:</span> <span class="token atom symbol">:premium_user</span><span class="token punctuation">)</span><span class="token punctuation">}</span>
  <span class="token keyword">end</span>

  <span class="token keyword">def</span> customer_type_to_rdf<span class="token punctuation">(</span><span class="token atom symbol">:premium_user</span><span class="token punctuation">,</span> _user<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token attr-name">do:</span> <span class="token punctuation">{</span><span class="token atom symbol">:ok</span><span class="token punctuation">,</span> EX<span class="token punctuation">.</span>PremiumUser<span class="token punctuation">}</span>
  <span class="token keyword">def</span> customer_type_to_rdf<span class="token punctuation">(</span>_<span class="token punctuation">,</span> _<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token attr-name">do:</span> <span class="token punctuation">{</span><span class="token atom symbol">:ok</span><span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">}</span>
<span class="token keyword">end</span>
</code></pre></div><p>Note, that if you provide both <code>from_rdf</code> and <code>to_rdf</code> functions, you can use any type of value on this property, even ones for which no corresponding datatype is supported.</p> <p>Custom fields also support custom <code>:from_rdf</code> mappings. So, if you want to define a custom mapping to a field which should not be mapped back to RDF, you can do so with a custom field.</p> <p>The mapping functions can also be defined in a separate module by providing a tuple of the module and function name on the <code>:from_rdf</code> and <code>:to_rdf</code> options.</p> <div class="language-elixir extra-class"><pre class="language-elixir"><code><span class="token keyword">defmodule</span> User <span class="token keyword">do</span>
  <span class="token keyword">use</span> Grax<span class="token punctuation">.</span>Schema

  <span class="token keyword">alias</span> NS<span class="token punctuation">.</span><span class="token punctuation">{</span>SchemaOrg<span class="token punctuation">,</span> FOAF<span class="token punctuation">,</span> EX<span class="token punctuation">}</span>

  schema SchemaOrg<span class="token punctuation">.</span>Person <span class="token keyword">do</span>
    property <span class="token attr-name">name:</span> SchemaOrg<span class="token punctuation">.</span>name<span class="token punctuation">,</span> <span class="token attr-name">type:</span> <span class="token atom symbol">:string</span><span class="token punctuation">,</span> <span class="token attr-name">required:</span> <span class="token boolean">true</span>
    property <span class="token attr-name">emails:</span> SchemaOrg<span class="token punctuation">.</span>email<span class="token punctuation">,</span> <span class="token attr-name">type:</span> list_of<span class="token punctuation">(</span><span class="token atom symbol">:string</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token attr-name">required:</span> <span class="token boolean">true</span>
    property <span class="token attr-name">age:</span> FOAF<span class="token punctuation">.</span>age<span class="token punctuation">,</span> <span class="token attr-name">type:</span> <span class="token atom symbol">:integer</span>
    
    property <span class="token attr-name">customer_type:</span> RDF<span class="token punctuation">.</span>type<span class="token punctuation">,</span> 
             <span class="token attr-name">from_rdf:</span> <span class="token punctuation">{</span>CustomMappings<span class="token punctuation">,</span> <span class="token atom symbol">:customer_type_from_rdf</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
             <span class="token attr-name">to_rdf:</span> <span class="token punctuation">{</span>CustomMappings<span class="token punctuation">,</span> <span class="token atom symbol">:customer_type_to_rdf</span><span class="token punctuation">}</span>
    
    field <span class="token atom symbol">:password</span>

    link <span class="token attr-name">friends:</span> FOAF<span class="token punctuation">.</span>friend<span class="token punctuation">,</span> <span class="token attr-name">type:</span> list_of<span class="token punctuation">(</span>User<span class="token punctuation">)</span>
    link <span class="token attr-name">posts:</span> <span class="token operator">-</span>SchemaOrg<span class="token punctuation">.</span>author<span class="token punctuation">,</span> <span class="token attr-name">type:</span> list_of<span class="token punctuation">(</span>Post<span class="token punctuation">)</span>
  <span class="token keyword">end</span>
<span class="token keyword">end</span>

<span class="token keyword">defmodule</span> CustomMappings <span class="token keyword">do</span>
  <span class="token keyword">def</span> customer_type_from_rdf<span class="token punctuation">(</span>types<span class="token punctuation">,</span> _description<span class="token punctuation">,</span> _graph<span class="token punctuation">)</span> <span class="token keyword">do</span>
    <span class="token punctuation">{</span><span class="token atom symbol">:ok</span><span class="token punctuation">,</span> <span class="token keyword">if</span><span class="token punctuation">(</span>RDF<span class="token punctuation">.</span>iri<span class="token punctuation">(</span>EX<span class="token punctuation">.</span>PremiumUser<span class="token punctuation">)</span> <span class="token operator">in</span> types<span class="token punctuation">,</span> <span class="token attr-name">do:</span> <span class="token atom symbol">:premium_user</span><span class="token punctuation">)</span><span class="token punctuation">}</span>
  <span class="token keyword">end</span>

  <span class="token keyword">def</span> customer_type_to_rdf<span class="token punctuation">(</span><span class="token atom symbol">:premium_user</span><span class="token punctuation">,</span> _user<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token attr-name">do:</span> <span class="token punctuation">{</span><span class="token atom symbol">:ok</span><span class="token punctuation">,</span> EX<span class="token punctuation">.</span>PremiumUser<span class="token punctuation">}</span>
  <span class="token keyword">def</span> customer_type_to_rdf<span class="token punctuation">(</span>_<span class="token punctuation">,</span> _<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token attr-name">do:</span> <span class="token punctuation">{</span><span class="token atom symbol">:ok</span><span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">}</span>
<span class="token keyword">end</span>
</code></pre></div></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/rdf-elixir/website/edit/master/content/grax/schemas.md" target="_blank" rel="noopener noreferrer">Edit this page</a> <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></div> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
        â
        <a href="/grax/installation.html" class="prev">
          Installation
        </a></span> <span class="next"><a href="/grax/api.html">
          API
        </a>
        â
      </span></p></div> </main></div><div class="global-ui"><!----><!----></div></div>
    <script src="/assets/js/app.9947d21f.js" defer></script><script src="/assets/js/2.9c83fda1.js" defer></script><script src="/assets/js/14.16bc6703.js" defer></script><script src="/assets/js/3.6456fe17.js" defer></script>
  </body>
</html>
